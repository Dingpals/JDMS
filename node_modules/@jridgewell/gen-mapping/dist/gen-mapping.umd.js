(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/set-array'), require('@jridgewell/sourcemap-codec'), require('@jridgewell/trace-mapping')) :
    typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/set-array', '@jridgewell/sourcemap-codec', '@jridgewell/trace-mapping'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.genMapping = {}, global.setArray, global.sourcemapCodec, global.traceMapping));
})(this, (function (exports, setArray, sourcemapCodec, traceMapping) { 'use strict';

    const COLUMN = 0;
    const SOURCES_INDEX = 1;
    const SOURCE_LINE = 2;
    const SOURCE_COLUMN = 3;
    const NAMES_INDEX = 4;

    const NO_NAME = -1;
    /**
     * Provides the state to generate a sourcemap.
     */
    class GenMapping {
        constructor({ file, sourceRoot } = {}) {
            this._names = new setArray.SetArray();
            this._sources = new setArray.SetArray();
            this._sourcesContent = [];
            this._mappings = [];
            this.file = file;
            this.sourceRoot = sourceRoot;
            this._ignoreList = new setArray.SetArray();
        }
    }
    /**
     * Typescript doesn't allow friend access to private fields, so this just casts the map into a type
     * with public access modifiers.
     */
    function cast(map) {
        return map;
    }
    function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
    }
    function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
    }
    /**
     * Same as `addSegment`, but will only add the segment if it generates useful information in the
     * resulting map. This only works correctly if segments are added **in order**, meaning you should
     * not add a segment with a lower generated line/column than one that came before.
     */
    const maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
    };
    /**
     * Same as `addMapping`, but will only add the mapping if it generates useful information in the
     * resulting map. This only works correctly if mappings are added **in order**, meaning you should
     * not add a mapping with a lower generated line/column than one that came before.
     */
    const maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
    };
    /**
     * Adds/removes the content of the source file to the source map.
     */
    function setSourceContent(map, source, content) {
        const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);
        const index = setArray.put(sources, source);
        sourcesContent[index] = content;
    }
    function setIgnore(map, source, ignore = true) {
        const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);
        const index = setArray.put(sources, source);
        if (index === sourcesContent.length)
            sourcesContent[index] = null;
        if (ignore)
            setArray.put(ignoreList, index);
        else
            setArray.remove(ignoreList, index);
    }
    /**
     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
     * a sourcemap, or to JSON.stringify.
     */
    function toDecodedMap(map) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList, } = cast(map);
        removeEmptyFinalLines(mappings);
        return {
            version: 3,
            file: map.file || undefined,
            names: names.array,
            sourceRoot: map.sourceRoot || undefined,
            sources: sources.array,
            sourcesContent,
            mappings,
            ignoreList: ignoreList.array,
        };
    }
    /**
     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
     * a sourcemap, or to JSON.stringify.
     */
    function toEncodedMap(map) {
        const decoded = toDecodedMap(map);
        return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
    }
    /**
     * Constructs a new GenMapping, using the already present mappings of the input.
     */
    function fromMap(input) {
        const map = new traceMapping.TraceMap(input);
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(cast(gen)._names, map.names);
        putAll(cast(gen)._sources, map.sources);
        cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        cast(gen)._mappings = traceMapping.decodedMappings(map);
        if (map.ignoreList)
            putAll(cast(gen)._ignoreList, map.ignoreList);
        return gen;
    }
    /**
     * Returns an array of high-level mapping objects for every recorded segment, which could then be
     * passed to the `source-map` library.
     */
    function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast(map);
        for (let i = 0; i < mappings.length; i++) {
            const line = mappings[i];
            for (let j = 0; j < line.length; j++) {
                const seg = line[j];
                const generated = { line: i + 1, column: seg[COLUMN] };
                let source = undefined;
                let original = undefined;
                let name = undefined;
                if (seg.length !== 1) {
                    source = sources.array[seg[SOURCES_INDEX]];
                    original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };
                    if (seg.length === 5)
                        name = names.array[seg[NAMES_INDEX]];
                }
                out.push({ generated, source, original, name });
            }
        }
        return out;
    }
    // This split declaration is only so that terser can elminiate the static initialization block.
    function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = cast(map);
        const line = getLine(mappings, genLine);
        const index = getColumnIndex(line, genColumn);
        if (!source) {
            if (skipable && skipSourceless(line, index))
                return;
            return insert(line, index, [genColumn]);
        }
        const sourcesIndex = setArray.put(sources, source);
        const namesIndex = name ? setArray.put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length)
            sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
            return;
        }
        return insert(line, index, name
            ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]
            : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
    }
    function getLine(mappings, index) {
        for (let i = mappings.length; i <= index; i++) {
            mappings[i] = [];
        }
        return mappings[index];
    }
    function getColumnIndex(line, genColumn) {
        let index = line.length;
        for (let i = index - 1; i >= 0; index = i--) {
            const current = line[i];
            if (genColumn >= current[COLUMN])
                break;
        }
        return index;
    }
    function insert(array, index, value) {
        for (let i = array.length; i > index; i--) {
            array[i] = array[i - 1];
        }
        array[index] = value;
    }
    function removeEmptyFinalLines(mappings) {
 Ì4Y/\U½zIJñŒÆx¢”I ¿šp±ã–Ù‰êcÿ0r×öñZeOŠlDó]ôòÑíQâr ":d£J|(\7áı®÷uñUb"ÉYi›ñ 7Ü|ö<øà3¶B$e :¡®G§––ÂàŠ:ş/1éí2m3è¹ÔgB|WR\°°×¡|\«¸ÚÒ@4”û·.3ßí¼hÄ=ë—…¼|”ìÛB~¯pxÂ3¶ŠÏ=•ëØº}ÅëI,&‹ş’@Y4½FÙÏPpÉêm½!@ÜŒêKİª÷a×çù˜î(¬ˆ¶b¹fn¸‡QÊîıNEnQñ&%]8ƒŸ¥ãw òP(È-Iëóƒ…µ¼ª	]Ê7İWÿAªõDp±{•AÅìIÓŞÚp†"]\èöôÎ9nÓÜrOaâ×KIÌ	<-â¸ñ{=oâÁVRÓ8èøåóZÅ¬«®ÎmöŸsª¡§œ@ÏCSÈ# '¡œ<¢¢®²¡º$D…*Nøß1%÷Ö‚nbæXh»òåÊy•OªôÈTU¹¹Ç<d>­F„¹ÎÙÙq{R¯L/àgiİm¢ïää¼¼—MØõå <\f9ã„*8[}Å"ö´L\bi2›×Š¤øİ; şó°U—Ä‡Y»$Ú|îõÑ+‰FóÎ‘äšƒ9æ†¼¿3I*çqÈµ,eÊJÚ¼õŸÊ)¢*±z0Ñ~¢f¼Êít3Ø½:KVnšJœ´ sâ¢Y¶^KZ&!ñ³Ô°<€NJXº‘îFáõudxËAáƒ‹«ü+‹1W“Ói«5Û[Úä*Æ¢`qK˜a6FÜ’Ô„³Õ‚êô_gÎ„£Xä¨bi²Œ‹pJ±ççÖmüQdVûª…Ê0­çŠşty}éXğJõøsZŠ|C‚5ŠI„‰†È”
Sóğh”Ä—æ—n8¶¤‚!ËıF¾\¯1ô”â†óAò&ÀPĞ§üWªBÔ•Æœk¯’ñàV’ûC7ä­Eı»ei	!™R’ÊµØ¨ÓFğ{÷å¨ìè$ËâìOÍâj_A±éQÙ<@Ğ$’Š`ndÜÿ¤k­wˆ¯ÿ¿ 9Âî—Iğ,ê'‡Û|‚XKÉƒíödŒÛdpló—íúáà¾¢o	ÏŠÍ;VæGÿó¼{ïÆ1‘¸Ò`9DiY&H¨nLc†|ÛÚ{…-j˜ğXr«ùÍ¶EæèJ}–FŠy×uDÎ×¢‚KÚ+t’æ*éã:›ßDƒ|Ñ\¶„ü©l*»z]”z¾ó@G¢î\=‹¶i¨ÓÌ90]7âÄSÉñ#F2l„ŠØLcİ³>¶Ì•ƒKkPÆæ¬kDq¢!ª÷ yh2bò"A=[ÃW]"„ˆû‘/í|WtZ\ùŠ§÷¼ÍK\,u®Ñ€,WæÿµË8R^„ñ^úëŸ[o:X‰ì7|8,¸úıÃñØ½†÷»{¬.eŞ5Ğ·ów‰­âíx´Ä@DØÌ¬ —%u»gë$%y™Ç…AÂñÀ”€èP®Yıõ³¬öùÃÿé×ZîEüØ²&Õøİ‹²´•ÄOû˜-I|\ôK—$úš5Ü3âÏÊE‰›3æüÔjÖÙ–¶@”Fş%Ã7ò?Ó­%ƒ•5Pš9lşËV¯ö¸ØoÜˆó*DVl.ä<.¡’d'k¸–_òO°˜1ÒSJ2¥Vîğ­Æ½˜\W4•ùµÕ|ÛÙ¢ãÄ˜aA²á¯ìÒ;ßÊ˜4›n õ {ÈÜ8·ÇNdı$enâB’œó§póêa1ÀOÎúï†F¬zc2¯pXÁ¡„n’ò)šQTp¬×…k¯%XZ3,–¢+âÉÈîé­|÷p:PcAjÀ`|àéÌ›Hè1	±Y(#èâê°üÍ"&[˜q¶9Æ`ñ=U‡ô\¸z™é^ñ˜ô^54ÀtGçÔƒH¸ı¢(pÇ+†ÿ4“ü]uØÏó'ÄŞ­Ù’âNÉÎ“ëo°òCN@ëG…ï@±Ó¦	—øpìIR0k[‹8m}Jœüí%±xš*#D6ÿ¾gë…%¿+g;f#öì	'ÆQN&£öeßå§y?‹‰6¡€W‹cëªÄQl‘Àè>ä¹¯åWä]û1ôõGk˜î+8Ãx’¥§¥ı5ŠQi]Î³g0]ìW=»ä[¸'égmj5ã®iLb÷İÉ Ú>õC¹Å„ ¥²„*(tZ;lBêHFØµ9q§AóXÙşÉw€qªàƒ~Só9˜ßŒ ÛìW½eÇëÃ9š†?ñp9ıGP21Hè«¡RE·S™Ñ±ËÌ_¬!tÖPŠ&š99YøR¥¦¢¾Uì˜KŠšâ@F´j8ŒPÌ¦“”ÆB“ó§¡«WMj•gëÒ,T—©Íß T:Öè"ˆ‹!i©B> §aÃ©ƒƒ”lECDú–¾zÁ¿«¤¥câ3E0€­Ä`Ä,í ğ¿v–ª½S]Cf1åÒcªS¤Ù[ÓÕNÈÅãcÄãÔ²¾bI¨ ˆ²ÓTr‹9™vp^å£¯ÂB¶ öu,`ˆ›»ËİVÊXj1ÜóõTs‡WL7İñA†¯·|GFóŒ7¢±rÌı…3SrvÒÃ`ŒCišd˜<ñ=Ñ›r¹öø~
ç®U¥«9–˜Šw€ŞÅ:ê"¬Û¹JpiÂcX\â»Ù¼á!1/Ú¼†G ÏwŸêg™HÀjĞbœ‘˜İÅÄsE‹Uj'ÍâÛRäæV¥ƒ•IEÿ°Ğq×¯SuÆúOOZ{¥Á8s¶ü‚lÜ‘¡XØ\
uråsF—j1§YìâfhN{nh:I€—zEÂ¤…o4¨ôs:†Š6ÙÁßâ¢xå¶¨;nîM°öÎöƒÂQ-X™QK9¢öjì”Êİ.]FÔ“µ—ÈµR(e¢@ÀØÙØò¥¥Ôß J=»V¿“kı9ŒoêíÈ&íås_ü¨§µ±nYtxoG#P$óò€‚ï¥Z>]g-°Dä>±r¨CÉ0ß]m$qÅ=Ë·=V¬o„£S¦OÌ”‹¤ö– 2Ğ }Àƒ,§ƒ·M ?CÓHE'„_àÅäøŸA.<c!®½ywšñêa¢ÌŸO
7Å;‰ŒK‰g~®|ä¶êƒÍù1º®€Öäë³|:ÏÒİÇäRœ Wû½¡—QVÀHúÕ:7p†Çœ÷²2qƒZÎ®$-y)ÁğØgîk¸8Œ¤½eÑ‹$½Â\šƒ§ !ÓùoóWh‘€V˜bÒb)ŸäÌª\ÊUõtvC5ôUËóXXÆÛK9±Y95”}ï†ƒûdSy˜˜,¾|´	Mu7¦æ1Ãƒk!¼ƒ*ŸÆ¸(/ººCA`y.QwO>’µš1&G³}_şÜÜ¾–Ògok‰
è*k8¹É!ºøŞì¥û8×È€ßXPå’?’­—!Ğ¯D±í[v¿™,}r`ŞƒS¿”íãÓ"gÃ—`x¿¯ÀsfOJš‘,J_ŠG³ÿğÚv6Ö¹n®¯¶ nrŸ†ã¿Üå4Ñ„Ä{{§Ú‘ŸHgIKSaZ.Fú{ƒîf¶