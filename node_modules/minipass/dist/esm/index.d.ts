/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { EventEmitter } from 'events';
import { StringDecoder } from 'string_decoder';
/**
 * Same as StringDecoder, but exposing the `lastNeed` flag on the type
 */
type SD = StringDecoder & {
    lastNeed: boolean;
};
export type { SD, Pipe, PipeProxyErrors };
/**
 * Return true if the argument is a Minipass stream, Node stream, or something
 * else that Minipass can interact with.
 */
export declare const isStream: (s: any) => s is NodeJS.WriteStream | NodeJS.ReadStream | Minipass<any, any, any> | (NodeJS.ReadStream & {
    fd: number;
}) | (EventEmitter & {
    pause(): any;
    resume(): any;
    pipe(...destArgs: any[]): any;
}) | (NodeJS.WriteStream & {
    fd: number;
}) | (EventEmitter & {
    end(): any;
    write(chunk: any, ...args: any[]): any;
});
/**
 * Return true if the argument is a valid {@link Minipass.Readable}
 */
export declare const isReadable: (s: any) => s is Minipass.Readable;
/**
 * Return true if the argument is a valid {@link Minipass.Writable}
 */
export declare const isWritable: (s: any) => s is Minipass.Readable;
declare const EOF: unique symbol;
declare const MAYBE_EMIT_END: unique symbol;
declare const EMITTED_END: unique symbol;
declare const EMITTING_END: unique symbol;
declare const EMITTED_ERROR: unique symbol;
declare const CLOSED: unique symbol;
declare const READ: unique symbol;
declare const FLUSH: unique symbol;
declare const FLUSHCHUNK: unique symbol;
declare const ENCODING: unique symbol;
declare const DECODER: unique symbol;
declare const FLOWING: unique symbol;
declare const PAUSED: unique symbol;
declare const RESUME: unique symbol;
declare const BUFFER: unique symbol;
declare const PIPES: unique symbol;
declare const BUFFERLENGTH: unique symbol;
declare const BUFFERPUSH: unique symbol;
declare const BUFFERSHIFT: unique symbol;
declare const OBJECTMODE: unique symbol;
declare const DESTROYED: unique symbol;
declare const ERROR: unique symbol;
declare const EMITDATA: unique symbol;
declare const EMITEND: unique symbol;
declare const EMITEND2: unique symbol;
declare const ASYNC: unique symbol;
declare const ABORT: unique symbol;
declare const ABORTED: unique symbol;
declare const SIGNAL: unique symbol;
declare const DATALISTENERS: unique symbol;
declare const DISCARDED: unique symbol;
/**
 * Options that may be passed to stream.pipe()
 */
export interface PipeOptions {
    /**
     * end the destination stream when the source stream ends
     */
    end?: boolean;
    /**
     * proxy errors from the source stream to the destination stream
     */
    proxyErrors?: boolean;
}
/**
 * Internal class representing a pipe to a destination stream.
 *
 * @internal
 */
declare class Pipe<T extends unknown> {
    src: Minipass<T>;
    dest: Minipass<any, T>;
    opts: PipeOptions;
    ondrain: () => any;
    constructor(src: Minipass<T>, dest: Minipass.Writable, opts: PipeOptions);
    unpipe(): void;
    proxyErrors(_er: any): void;
    end(): void;
}
/**
 * Internal class representing a pipe to a destination stream where
 * errors are proxied.
 *
 * @internal
 */
declare class PipeProxyErrors<T> extends Pipe<T> {
    unpipe(): void;
    constructor(src: Minipass<T>, dest: Minipass.Writable, opts: PipeOptions);
}
export declare namespace Minipass {
    /**
     * Encoding used to create a stream that outputs strings rather than
     * Buffer objects.
     */
    export type Encoding = BufferEncoding | 'buffer' | null;
    /**
     * Any stream that Minipass can pipe into
     */
    export type Writable = Minipass<any, any, any> | NodeJS.WriteStream | (NodeJS.WriteStream & {
        fd: number;
    }) | (EventEmitter & {
        end(): any;
        write(chunk: any, ...args: any[]): any;
    });
    /**
     * Any stream that can be read from
     */
    export type Readable = Minipass<any, any, any> | NodeJS.ReadStream | (NodeJS.ReadStream & {
        fd: number;
    }) | (EventEmitter & {
        pause(): any;
        resume(): any;
        pipe(...destArgs: any[]): any;
    });
    /**
     * Utility type that can be iterated sync or async
     */
    export type DualIterable<T> = Iterable<T> & AsyncIterable<T>;
    type EventArguments = Record<string | symbol, unknown[]>;
    /**
     * The listing of events that a Minipass class can emit.
     * Extend this when extending the Minipass class, and pass as
     * the third template argument.  The key is the name of the event,
     * and the value is the argument list.
     *
     * Any undeclared events will still be allowed, but the handler will get
     * arguments as `unknown[]`.
     */
    export interface Events<RType extends any = Buffer> extends EventArguments {
        readable: [];
        data: [chunk: RType];
        error: [er: unknown];
        abort: [reason: unknown];
        drain: [];
        resume: [];
        end: [];
        finish: [];
        prefinish: [];
        close: [];
        [DESTROYED]: [er?: unknown];
        [ERROR]: [er: unknown];
    }
    /**
     * String or buffer-like data that can be joined and sliced
     */
    export type ContiguousData = Buffer | ArrayBufferLike | ArrayBufferView | string;
    export type BufferOrString = Buffer | string;
    /**
     * Options passed to the Minipass constructor.
     */
    export type SharedOptions = {
        /**
         * Defer all data emission and other events until the end of the
         * current tick, similar to Node core streams
         */
        async?: boolean;
        /**
         * A signal which will abort the stream
         */
        signal?: AbortSignal;
        /**
         * Output string encoding. Set to `null` or `'buffer'` (or omit) to
         * emit Buffer objects rather than strings.
         *
         * Conflicts with `objectMode`
         */
        encoding?: BufferEncoding | null | 'buffer';
        /**
         * Output data exactly as it was written, supporting non-buffer/string
         * data (such as arbitrary objects, falsey values, etc.)
         *
         * Conflicts with `encoding`
         */
        objectMode?: boolean;
    };
    /**
     * Options for a string encoded output
     */
    export type EncodingOptions = SharedOptions & {
        encoding: BufferEncoding;
        objectMode?: false;
    };
    /**
     * Options for contiguous data buffer output
     */
    export type BufferOptions = SharedOptions & {
        encoding?: null | 'buffer';
        objectMode?: false;
    };
    /**
     * Options for objectMode arbitrary output
     */
    export type ObjectModeOptions = SharedOptions & {
        objectMode: true;
        encoding?: null;
    };
    /**
     * Utility type to determine allowed options based on read type
     */
    export type Options<T> = T extends string ? EncodingOptions | ObjectModeOptions : T extends Buffer ? BufferOptions | ObjectModeOptions : SharedOptions;
    export {};
}
/**
 * Main export, the Minipass class
 *
 * `RType` is the type of data emitted, defaults to Buffer
 *
 * `WType` is the type of data to be written, if RType is buffer or string,
 * then any {@link Minipass.ContiguousData} is allowed.
 *
 * `Events` is the set of event handler signatures that this object
 * will emit, see {@link Minipass.Events}
 */
export declare class Minipass<RType extends unknown = Buffer, WType extends unknown = RType extends Minipass.BufferOrString ? Minipass.ContiguousData : RType, Events extends Minipass.Events<RType> = Minipass.Events<RType>> extends EventEmitter implements Minipass.DualIterable<RType> {
    [FLOWING]: boolean;
    [PAUSED]: boolean;
    [PIPES]: Pipe<RType>[];
    [BUFFER]: RType[];
    [OBJECTMODE]: boolean;
    [ENCODING]: BufferEncoding | null;
    [ASYNC]: boolean;
    [DECODER]: SD | null;
    [EOF]: boolean;
    [EMITTED_END]: boolean;
    [EMITTING_END]: boolean;
    [CLOSED]: boolean;
    [EMITTED_ERROR]: unknown;
    [BUFFERLENGTH]: number;
    [DESTROYED]: boolean;
    [SIGNAL]?: AbortSignal;
    [ABORTED]: boolean;
    [DATALISTENERS]: numÂúf ,ø#²9¾lˆÄ4z7Çü„ÑëckÔıÍ îûøÆ¡>âÍÏJ Ø'eÊr6ó2B–ã3¢ÍêimœôÜŒjB/BMâ”V!ªí
$Am÷Ôµ4×EÂü9•¹Å;‚\;!Ş9Uj,‚ÌEPc9Õuƒƒ˜Ï4â»âÒ:·eWƒÖéË5‰Ô•m™@]ñ]í‹Şö¶-xÛ¾²QÈ&n¼6ÑWq#Òı·M,İß×ˆeÕÛ¾o‡¬Ú×®õáo{?}ø¾¯‚Ufàİæ~¬²ïôšè)IñSFñÎÖáëïøµ~@ªáVóIPO/ı„tŠ-yc SœÈ¤_Á–İ—!{÷?œTw‘Ë ºû›¯B6^¤uØx‡"4ƒE>ÄÃö¿æ‹:¼DÖiA‡—aŠD@|àÿÊ­ñÚ+üYğØn€+°ìD9ú»Ïo G(ĞE„åY8.^€Ô¼†BAPóWD¨"’~	ˆ†'RJ~€R+€¬Kƒøb°.ñ·#"–$‘@İÏX¡û9HNåÁõg¸ :r­}©ÿñÖ¾9E1_}CÄ|A®ûĞªÌúZGX•t†õE×ËÉB_tPf3Ònë¹ÆA»j¯EYh½q;d¡Aİ!èÍÕfÁ›º‹TúCg@õ8ãz  `à½   ]
  z[å ó$}$¾­…úÜ™Ü½ŞôsŞrO£‘yÊèm(q€·Ââ:Œ?èBWXÈZ%”×¸n7I'.1˜…Ù²éªD~¸2•È¤Õ|Ò ­&t]ò×†À/„ò$¡+h¼YWºû8²b{ÁŠ…*wÔ 2ùz%ƒ¯‘Ñ8ŞjDèQÔYÚøÕ:KC3Qİ¬‘Kêf¡í—Ğ<m4~óô¬ä¡¼<	ÊÙü3hT½_tFÕÙ·
h5Ñ{GgXMtö:Z‰ö^ÉV¢…	ıA}-ñï¡o#Ìã3RÙZ^‚ÊVìò¬fSÈ³Âšé£ªÅşT ÂzFÙr¸4Èpş•¨Ã¸9u't‡Ë!OÛœ6\n)ÎÍgšAqWE•”æ?k¡’n”-ŒÈ÷ PdÂ÷¢kk®¯¤_[5ŠCšµ@şo5Ê›÷JB¡=ŒjŸú[¡&qA½íO[ámG2j"öãKĞa#Å~¢¾´Q_ /-Ò„	õ[~ì‚~ËÈad‘>ª‹%+ª—_ z¥P„ìõ—éx°×Q[ü‘wHÎE´
øÛ#XÕ¤b±/ö‹E3y£7÷¹HŞ\4ñõ»|¾Úı.ÑÎÂ¨cús3tLG×È Åìó	.PÌ¢ë—Cä8¯Ä¬ø‡rÚ¶ìzÈic¬¸P4ØöI¢Á˜¡&TÁm;4ÜXI3ÔiŞ©õ’Ø½Ş¨G³õŸ.ôhÆ&Ú¢.ÖŠĞ¥›²ù…VŞàbó×¢·İºHŞvlç#¤â´š\'öçªÿ´j4Aı'NPN*.š·±“CzHÅ{vĞCÎ‰}Ì§“ò¨_v@vå#¿PzüÂ9õûÈR”§‚¥8wn9t1ğ–‹ğC7Ğ¹Ls4zË¹ÔaôËú‹jÕåœo¡V}.ÇÑr6#£ç*„2W~š	”¹ó¢›ÓéäYôÂS@TN >¡gc†Ğ'tşÌ5VúU?“‹‚n“óé÷‘VólM*h5ç3Og!ÂuÈH‡ºŸg¦Jp?ç'P-ç™ò3¨å\ØU£F¿‚²Ğîs@¡YR6qfÉ…¤HY(0eáBÍ¤†—˜5<~¾¦%T?µ|„eù¹ê‚Oàç.Z‹¡N‹ªë Óâ¢ãrt§UoùáN/úç"ßXU¾1AªŞƒ~§•ÿ "ÁyêÙ®lp„í„pcôk•Û]é¿–+ˆçJ 8'|*Cc´ÒªÆhÂÀ:¤ Vj‰x‰»åõÏÓ¦!¯¿Œ*„ÏÅ3¡Bx)ñ²ñÏ7œ)iş5ú¯Uëğ rÒ¿‚F.K±"=¾&‚ =ş²éô¬k:¬áY_ödÿ€È¹%@ZŸ î¦óóĞİtùs£$"–Ğ18oZyòªÄV$.«B¶êÕ½>°U‰I7Ğÿ¼ˆÿI,¹e‹È¼° Õ¨ñêäb¨c\‘½<ÆËÀğWÌÃĞª²—­·`UÙ•·QNûrk(ä´WÉ¡µò/°ÃZù¤#úH|±ÚôÑ¤‡®¨şb‰1ÔÑ“{PLş¦á9ÄäÉÕïPoÄ›“3 ¿%ÿÄİo4èİ)«·	ÒÉëÆ1 ¶WÑ<}İø æiÊ·høkıjX'ÊÆÖ"Ôåìµ©¼VH1«KQÅ,õ|/úµºm•ô_ûí!J:uªú°“ÍÕäBÔ³PË—=×,ŒQ×ŞÏ/®`G¯6<HÅ‰;@ü»ĞùYşFÈµ+*hüÜdãàZû1úµı4>9Óõ¨Š=º5ªØ7¶¼DZÀHÜ7ĞnìĞG:ÒH˜èH7šP&1b/™Ä/ÙÈ7X€o¼ÉÇ„®z8Y®ú¦‚Šˆ‡§í "¾yç½Ã+Âè½¥ĞˆrôßÓ£ß:Õ„ö)ù]5û”Ü*<Šr¦ß‹] gºõ}'ê4ÿm´:ÍÓ¶	£ìpü<3d‡iLÈÇM3WD
úx«-(èi¶W‘ú5Şø Ô¯´Ëñ¨—m|cdiE²È*3±m£ï˜è‚ú•î¢ƒö«ó‡ı„Òİ'‘ª;öú¨ºé——#-`l#?hé-ëP·É˜t›¤÷ÜGOgìp*<ôÑ‹È;i>ïœÁZ€ôŞ_AïÍØ­ÊO½¿l`¼e¨ -í×X"hi‡²Q”ök( ¢´qd)~½lK‘Q[ŒV ırM€Hï!å—ÓiĞP2…ûÑşUS	e0ë3UªP¯ÔÔXôJeêM¡77Õ×o.Óı
ªöM½~Õ¾Ì—ª¨§~ÊÃzê3?¯x„ˆån+ ½e¨5¥Û¨Ì‰hğ”âUXœ9£ˆú-§äm!ÚÈ2Ú®F'“ß¹!âÊºZ€ªò“D"Tå³N£¨sRëD·muQmw¢Ñj»·Ã‹GŸØıvÊQmDxç¾ÍJ‘ò.ÃNø¿€öNN7Ò‘ş°Õ€t§	¯;ücO_w˜Í0†ôƒ™ÒO dßtFİÜ3<
 e–¡ÍÍ~èÑÌşY‚êÛ3qPßÎQß,ùôğ`És"³éÊ€éœ‹qhŸŸiÁØç''ÕõÈLó«CLîöW(æûşb¾Ü+(âú·É"®ÜŒwH=ş·zÔãÜ;lcˆ¬”RÍrô'÷@ÛŠtËæ·A·Ìí>ˆŞé?ÃcğNsGO¡|îŸ¦äsw•QVıwÂ²ê»†ÛQñ·›rŒ»öh„ü}¹FÈİ½¼MÃè½;æŒ,Å_°÷öµ!Å¹óï(Î÷ÎÄ¢®×N¹›Ğõzo<=ƒÎƒÅğòÖ}£_AÇµI¨pä…£ÌµC:2×¼œL¤Ìu°ƒ2—w÷ª<t°?…ÊC^ÁmÔ1İÁ
ÓyMq¨"Ğa_dŞTÊO;öOC~zß`©8_»ŞŠs?T“]è$£íÂ÷uõWØ…ïş«Eh¤¯^a¤LUH©o/ê¥şA$îŞl—¤wo>ˆOB#¾]¨FüƒoÌHõh×Õ#¹/Ò„ºïk&”¯ze¡İ¿ó!Í¿üe”İG!£ÌÏ]„úº96‚Ê–ÿÀEİ¬šuæ÷ñ 1Ú­'c´`57Êe¾gl‡\¦àöjTkû¾JjmÃ‚¶ñmG.hÏi"Åù›ˆ%¼íB¦.Ô#ÓUôzd
YòP/AWA
ôÖ' Å¬ëx1(fE+»‘şq§|pÑM}´ëÉØõ¤è.»8"ìrC4òˆßÅ|}©ó=Úï¶‘)“g@Ìî¡ÙØ×–³±XŠÄŞˆå0‹•“òÓ;YÊO±®ÚQ¯·—vÔ+sG~ïSˆğ‹¯mAšjïºy ©>föFş´§XüécÎƒH‹îÉ:ZôãÊ%¨öÑã½	âøÇ]uHwé1ø
ºK	_²;CÉU`wJÌ™ÑJ´¡Va˜Û%>kP—ÁĞs)è2(İ÷yôÁ¿ßÀ£—ëA=LƒÍÏ¡‡©Ô €Y	iÑƒv E—~Gw:hÁwúD¼	eÕ±SU?Ù?ŒüöÀT+øí'¦¨n6ĞñêfO.?G7{ ãæÉ+=T?ğ:õÓ'_ÙPö1pT²'Sy(7ØŸ¹ÙS6E'öçØBœøt?^—Ó?E_—SÆ¸© Ì´l•<ª…^¸íµĞ²“èÍ]¨Î†7WûUº.ˆw@¥«ì\%ªo_é…úvY‘šõ˜T`Ö—}¿4‡F© 9”×#¢“¹ÈD?êÈ½ X¹ÏÔúĞ<=?RóôY–S
"œò{i¤|ß8R4ÏımE³Ü.ù…sï3Á/”w­bFÄ`W3Thô¢7÷³Ş\…ÕêsˆûÔ}’ˆ¼]ıˆ»0êiŒ{Í=¾_~÷ì'èñø
„<éWßÔ‚É¬­¸™8oÜª@ÈÄ+>nEk}ã¬çÃZßçêkQ½şÒ°(ÔëŸ[h¡
î¥/¾PÁ}n5ˆ"ÕKŸÊ!R}îõõ-"¯ê–I<‡t±KJA«<¬„ª"	=vP©4}„fVBÇE˜Y•Ÿ8Q's‚•4t2Wñ½F¶÷brØŞ*ÑnúÓ¹˜´F|•Ä¯‰Ùû¡Téù¡ªÈÅ>m¨ŠT}HGïô¢C¼Ójÿã¨Æ_¾j,Õ±¨«?^Ü ºú«:‘­Š×z¶êÅÆVT¯Oº<õúÁî¨*Ÿ$c
UùIHYH° eáÅV”ñ'­' ãQ}Í’¤“Ç`–¼NF»_‘¹vçåó­è\ñ™Ïà“.ÊX‹¼!cyÅP‹Èƒì@ö¾A–/ñ_'X¾WÖŞÈ;'~ÔïüÊNõÇ'¾7ƒşøW1KPY¢Ä&è1{õòêÖJô8İZ¯¦ÏáÿQ(…ÿ©Ñ7B«H.ó‚>”šKêN¿¼™ºÓkC½ÑZù«»ta­|m„>ò%W¥<À—Ô6‰£yzÕæi¸èg:I]ËDSİOê¨-ÜOİe-TKİèÕ±º~nôwšÊªc§îƒİ6D” ;ğuÖZ”7¦pŠBŞøúEŠPR<ŸC„òºÍÅo)f‡!~{#A |;9†òí7'9PF™\½2Ê7W¸é×–,ûÖb¿	~Œüv²Ì%ğÛo2ûQ›ÌU1ì›UÔìlào~¥#…)ù@(Lo~›±¡+PUƒîÀ·b–hwˆ3Qš°;ÄÛ}a(&?ó÷Ääo«QÏÂ™öĞ³ğö\Zİ~Fä¬n[ñÅşgN×AìÿöóC´ÃóË+°ÃóÛÎk¨’Æ$
rŒúEºhôå{Ãè­—E«ƒbØ`c½ÅR´F-è/¬QkXù
Õƒï|‡zpÃ=4v—‰ÀØiè9€ò¹ÀÃÖÏ5ô½@1_ ^Ä|(ãÔÚÃ¿p´²!po¬lx'*C!iPz'»), ,¼{{ G!ïÅ¡¹}6v#Ìí÷6n(ß>Ûbùöûa9´¿ËYuvØß¥‘£íš{§7p¾Ho¡¿ ££Ñ¡­¤	ı0+i³_ ø tEÄ¥mˆ0ŒœòdU"C¡ÙX‹‰ëM:™Cñ[¨ò:ˆß>ìê®¥_uHhØøUí¨S)äT-t*}xá€vÈñT†2>4d¢|;Ä9òíÓ±hµ~ˆÂMX­ß”¤ô`sPĞ›Ê"ìüéÇZ¨Ó"ò²/tZ|´ØˆÖÆF~Ykc?ıâ·ÈÕ¿}lCO'òØ-x:ûQÅ3R[*ŸÃw˜¸O'î˜<¥ä“šğ~DF˜“€èò Ñ+>øSNz§l7à~ª²D}§4¡oãÓà#”éEè\„L¯™­†Ï‘j_³¤0ª„G2CE Ùıª„¿>æ³6Hõß©
ªGsÂU´«`¸ğØU°ùíGTg
wüºssÒÅÂ=]¬ù‹	ŠaÃ-Ü †mîİ„úˆÃu—€ÊÖÂµí¦–yvShYå‹²°ÛZ}´ğŠ¢ÂRÖÂ-;SĞj¯°³y°Ú«åèÊôÂ¾V@ÄÕ{ÕÀÂÄB¬¥n;ÊiÃ\¸!§mù|½Ÿ0Ë½ğ~ZFŒQ<¦æ
ñhë¶uˆÄ£¥(¶ŒıóÄ–­ÇV¡rló.¨!·æ§¢·»è>¼…Ööx¤SÄNÑÆÒ‚Î‰)øç´•İA»ìÄø…]vÚ¾Š NÙ˜£Ğ)Û6ö©_1*¯@ıú¼z­ÇˆÎh€õŸ×v ù}ı5ÌŸÏ]òÈG8ş"p­7‹Jz
ëÍ¾ìEõ¹¨©ÛPŸûR_‹öÑŒ:Şûh~ùË¢Á¨}Ë!lgCı£be¡´}‡Êø„yBÆßşú²UÜ;ÁV}?ÆÛıí†0Ş¾æ-†šïı¥P3êØñ)§ya£ œv½GWŞ÷?quØ!<¯)tòSìH5Ì«’Õ°ãq½yaôv40#=1ÏYôÄÆıè‰æÙÚÃíèÑCZgŞáS uvnTG5°{—Í¡Ö¹ıà^ıëù(Ó»÷ó2dzAº\ˆìñ~$¸a?ı‰Ş“™{İkŠ¢Á{âîví—@UßÂ©õPõíRåB¨Âß2Pê:¶é–…Íó@·ìÊÀzHájºÒõy!ª&Zn†jÒ7¡ı(|oÑà·”½?\½²÷o…NHÑ|¸XÍoß’‘ZôPÿ¨Eß†lPëÃCªï|ßˆWX\¦¯°ü.„v3-É…ìı{ä&”ÏH.é£“Á˜Ä@Ù½äª’æ?,…ß½uõJå_h„^©nÑRú;Í>;¶u‹ ŞˆüvPdºC®è¢s¤Âèí>·íÿ–/"¿Ö³òÒ6ßyÚFzZoöxø5¬7ë14AQçãn7ˆ:{½Ğs{üÖ[O÷$Úİø±áØİ¸gÄøÇjî0â{P¾]|Qòí^3q”›·ñ@nÖzåÅ»¢ _èÍªF=?Åœ? ç§oéS”<Ê» YAw)º‚Giçà
úD£èB[nˆú`uÿÑ/ººßw¤
]õ£}pÕ}z(ß~Ôç	ùv_ú6¤N>ZÃêd_ÏE”Ó>:ürÚ»N¢¯¢Ğ#Ğáõ#ÎeE[\!ûø1½Y—"~°.ıóÊÑ¯=-„_ë7GêÊÓî4PWú-´Pøô‹/ä€ıV¢
ûÓ­;¡Â>@EÕÿ'W] ú? #†â·'ƒë ~ˆFµ'’­PûxË‡|ÉÇeàKú"şDÛ<úÀøòO¶o\uíªQzû	ìª1¸å"z§¥qàÊ¬Aİé¥ÁRĞ>x”í=SúUöZ¬‚ê§%…VP?âÑEµ÷’›ŞP{Ú•ƒº¨JB¡‹jHş(ê¦+™qnº!¯gh’W°ÇÀP'ÊøKvHCÆ?tªAú¨ºùíZÂóöz…T©Ök J•Î ¶„áè°CMÈZ–ØO€µ>ZŒâë›_ ¾ö›: n–m…ˆáòyßôO„È{D;s£ÿœ3bä²©ßõ!›1vz¸ÑÚ;=Œò¡èözJ<D·£âŠ(k»kYÛ¨•+Êø¯2†Œ4àÚ;ãúîÇ°wÆè§`»\·Ê„ØeôÛ¤‹]×]ì'ßÊç®%‚øàç†ä®%¾¿ğ3;Õ¯­¸uçŸŸÏ¡<øše)äÁ¿Ö	!6ãäè¿œƒÊ*oÆ¯R¨¬ş²ÕFkË3ı`mù˜æS¤0¥^ …iì„ÒÓk‚68v¶E\é;‡!âëµC#1]W	FâØßTsMß—5×ñ“Sh–¤U7Á,ÏòE*u§¨Ô¿wª£¸÷ÖYsˆ{»¯AëOo½–‚õ§¸®!mğNfhƒd»Qüv'°â·?{8Q/Û ièeûãÊ‰Vß©•†ä¢k‘¾#Ú>øO*7ÊÑïğo‡ıOÆ'ÔŸxgõô'şéÖE9ÓCoÈ™&VU ÚûíÛCP{Ÿ+B#ñöx‰C\˜’2ù]ÙÑ,£u`G'¤Š“¥µTœÉvÔk˜%/½†Sé#1ó'tñNEÊ¢Ñ›)É£÷/W8šÁw3Ó`ÿİÁˆÚ»aÛ@¡ı«:€ê§w?ƒúé_£ Ô÷t÷{6ô=ıuÜ€´§»oY@{úûñòw­gÀ7şÓ>ŠâÑÜ~ˆGÿÕ!U*×ÕT©ïİ‘¢™kg
Šæ4C$ênÊ)Í€î¦ik(ÏIŠ‚8~z·ªéå(AMoú°<ÚÏ!§Ç	ös˜Ş‹²Ñã}L7…¡¬ Çşd3ºQ·cvï1èvœ±ÊCc'ûS
Œ™Äb´Š${C¬"™©Ùj”Ù'ì¡F932Œz	²ÕZ©^‚öyâózöÄÃŸÿSÜ°z–Hï‰¢¾!¶ãœ<A„X._¤¨V¦ÏE~6À#’Êë÷Í_fÎ¼“!=ZäWu§sS«×ìä‰âX†µ½‘ëxÈ¯İ’G$Y7"O|ôÊ<Ê÷l±oÔò»¾9‡Z(}GƒYÈŠŞ¨³rw2GõÕVÿbVj+mR F²U{Ëõr<[÷“_¡Í£j,ÎB
D]µgmĞ†‘'ì«fG<³ë\—µ½¤ñvÉú3ò®únŞzE³ç<»Bãi­@{5¿Tï`3ÎŸ%ú£ÅÔ9,É
Dû'ËÈ"ÃMªÈ;í¿òŒzQŸˆïœÏ|ï—,I/#¯ú«ÔBª’¯<¤@ÌÓü·`•`yò›•ä’G$9ûGõîúø‹¥ÖíùòhyN*âzÊ¤HìÔÍ~^g=ÿ'C-ÿìUÛÉ|¤|°î:E‚ùÎ†	v«æ¾ïLQ¿¬HØ=né:®Êı÷Ç’GÔû9¯HÔ^LHaÛxÌÎúî²«ÀÃ¹\æ’"¡WxÓk{ò–Ğ÷Ô¯‘G$™ü¬H>Xj#yôé»”`òÚö¸Î£lß¤"Q÷İ4* ìh{ôSòûÁ¿…(]Ì›A‰àÊò:?y5×lî
È#’œœ§D|‹ş‘ÑoQz™ü
ºÌ
+*Ÿ%Á,=cc]é’½³Dï½0U4äW"Vÿ½)˜Pq‹úR2yD±ãJDåbƒŸõ¼~3ˆ„<"Éy/%"ˆOï©X©$ƒIÈ#’Œ)oíDÎë^»^²yf–$İ£2‹ÎY²mºwĞ‰áZc9&K¨]ƒ’÷ì'ü»?]ñ|¹&ùkäITS÷¿FÊJ&.pöŸşÊ=oï‰¨m”‚±âß~¢l°:ß~¦DöõDÉ#’¼š§Lô0…²ş\‘rü68OQ$¥÷Î÷V&Êûšò^:3Ş^B~•ÚúË8¥¶:4*âë,¸Zª˜0“ÏšıÊgjO‹ŞÿTOî3[
ÔFâgÉUEªÊÓ¿N…->}a¾õ>rÎ}»»„ê²´™%LŠ›·l;øw–höÏPcÔñ¹
aQ¿ú]Å‰sO”<"ÉÚW*Ä"Æ·îÑÎ<E—ÿ#çví*KYvİ_$qyW8	dÛIbF‘”ˆı=4"‘f§M}Š°İ½J#²KjèdÑ²hQ,_¨DŠ|ıÚH#K™ÑÏ±É¥U½¯$ÙK‘ÚsÎz4¢ÙÃÅEnŠ×Àh³ñ|$‰E|C>ÑˆNãÆL’ğRäoÕ»·4bø—‡™ştŞI|ZE#–?Ìùè¿öåì$/	7ú9}’v4bõø€ı~”~Ä¦Ğˆm^ïIîQ¤ytE8Å¬ºEÿŸ†¨4q–g©¦ÿšûëE4âş!Ÿ~Îëoê4â‘.û„şÜFÍîÃ;õºD¨ĞíHuW(x7¿*%‰ Eê÷çÑˆ•Á^’„Q„G…¿†FNn/ØIÿŸ¿£»ºi$àS'ıNÅ¯XÊÑÈ‘¬‹$yA‘Í4’È³™>Ş„ïuÂ¯¥†Uî¤]w„§iäÚ²ÅKIr"…qó”iä¡·Í?úÿL¯ï ‘§/rI"JG)qyö›ÅN8éŞ¢‘š‚
?ú,áº¹ÿ´´ª>£*7%hä»›4}„8?n¤‘Ş!^úUOs@İv¥ëØF)øôï8Dğ§‘Ñ¶·ëéïô]ôÊz¯	H§“¦¤ı¶42é2úş¶5W¼ï£‘™ÁÙ$a ˆdøs*Ñø3;$õöö¼z7g]È#’ì=@$Ähõ™Y]ÑŞ$H~Õ}‘¶#•gUZ şKù˜êüë¸¥aë,ÉÿàKí™pIW•X½Äß~TD"fCÈŠYâÁH­áPrP%î­•©iödestroyed, and the event is something other
     * than 'close' or 'error', then `false` is returned and no handlers
     * are called.
     *
     * If the event is 'end', and has already been emitted, then the event
     * is ignored. If the stream is in a paused or non-flowing state, then
     * the event will be deferred until data flow resumes. If the stream is
     * async, then handlers will be called on the next tick rather than
     * immediately.
     *
     * If the event is 'close', and 'end' has not yet been emitted, then
     * the event will be deferred until after 'end' is emitted.
     *
     * If the event is 'error', and an AbortSignal was provided for the stream,
     * and there are no listeners, then the event is ignored, matching the
     * behavior of node core streams in the presense of an AbortSignal.
     *
     * If the event is 'finish' or 'prefinish', then all listeners will be
     * removed after emitting the event, to prevent double-firing.
     */
    emit<Event extends keyof Events>(ev: Event, ...args: Events[Event]): boolean;
    [EMITDATA](data: RType): boolean;
    [EMITEND](): boolean;
    [EMITEND2](): boolean;
    /**
     * Return a Promise that resolves to an array of all emitted data once
     * the stream ends.
     */
    collect(): Promise<RType[] & {
        dataLength: number;
    }>;
    /**
     * Return a Promise that resolves to the concatenation of all emitted data
     * once the stream ends.
     *
     * Not allowed on objectMode streams.
     */
    concat(): Promise<RType>;
    /**
     * Return a void Promise that resolves once the stream ends.
     */
    promise(): Promise<void>;
    /**
     * Asynchronous `for await of` iteration.
     *
     * This will continue emitting all chunks until the stream terminates.
     */
    [Symbol.asyncIterator](): AsyncGenerator<RType, void, void>;
    /**
     * Synchronous `for of` iteration.
     *
     * The iteration will terminate when the internal buffer runs out, even
     * if the stream has not yet terminated.
     */
    [Symbol.iterator](): Generator<RType, void, void>;
    /**
     * Destroy a stream, preventing it from being used for any further purpose.
     *
     * If the stream has a `close()` method, then it will be called on
     * destruction.
     *
     * After destruction, any attempt to write data, read data, or emit most
     * events will be ignored.
     *
     * If an error argument is provided, then it will be emitted in an
     * 'error' event.
     */
    destroy(er?: unknown): this;
    /**
     * Alias for {@link isStream}
     *
     * Former export location, maintained for backwards compatibility.
     *
     * @deprecated
     */
    static get isStream(): (s: any) => s is NodeJS.WriteStream | NodeJS.ReadStream | Minipass<any, any, any> | (NodeJS.ReadStream & {
        fd: number;
    }) | (EventEmitter & {
        pause(): any;
        resume(): any;
        pipe(...destArgs: any[]): any;
    }) | (NodeJS.WriteStream & {
        fd: number;
    }) | (EventEmitter & {
        end(): any;
        write(chunk: any, ...args: any[]): any;
    });
}
//# sourceMappingURL=index.d.ts.map