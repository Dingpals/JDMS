import { BOM, DOCUMENT, FLOW_END, SCALAR } from './cst.js';

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = '0123456789ABCDEFabcdef'.split('');
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split('');
const invalidFlowScalarChars = ',[]{}'.split('');
const invalidAnchorChars = ' ,[]{}\n\r\t'.split('');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            const cs = line.indexOf('#');
            if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd = cs - 1;
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if (s === '---' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return 'doc';
            }
            else if (s === '...' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                return 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return ò•4X‚Îí‘¹«øÉe¯KyP·„šÓÔ¨«V^WkôMMòaú
’€¥£İ•ü÷ÃõRèÇYy‡}³¼÷Á¿õ²	„î$ÕIÔ¿,ìõ#¦•§‘«¡gŸ=t>Ü^yÈî0|Õv<{ÊU/å€læçEÌ{òS¢ï%¶N’</È3Xh%Ú~UJ¿=}©ÍC•¼Ô– wôÈ›wH°¼õ±ZŸ0ôc‡½êzÈšKL)šSv:ëå|çÒÕ‡‘•IS”$™ƒUÎ”7şFPÌ¼¿¦~æf‹%v#«ü"í§{¾ˆó³4ì¼Áãº³öR7Î õ…ùCzgMêiÙö+’¤HVß±¤Û˜óü»¾O^úOÿvŸ|´KìÅ½‹x‰uNÄuz7ÈÁ\ÛuSîKÉø
ük}‰2Ñ¡²Ø¨K²şÈ–ùDYæà‰-?—“\®òi•kŸâu&Â5Ó­œôöÑnáæìÄ¨À˜àµh¶›w[0`„y…ÉÎğ—Ïé®À€Õ³îæŸk=[Ïºøú»'øòwÛÉEH±úïÜı H,£¼M{û.¶”­¦)7á½TVzİ™§|› ™—wØòİ÷³.-@†zxïÄ=Ìí„SÎJê!eİ¾Ö?©-&îíí ù4x¢ı2Fô.k>JOp ¸÷³Bßu›e?†Ül=dğcŞó©Â·y!ÈÊKÏ	¦{Ïbš§;çZVò†•k"L`wY¦ğl¼ÅĞ²ß?rõ®°¾±Õén.ÁfCŸ³ =êÖ5tZ+¿şG&$*†U“½[æ™ögÓÊvûù¸x¸­À—ª)øøHü&ğÍö¨ã½ïB'¦ïıçV+àhBú/ÃßÛ:³5C>e’¦ºE~= cßŒ;BØ¢ßDgÈ‹½eV÷;ş†ÒgDi- 3Ç+Í~“Ä4odyğéJ´Ÿ;ZÁæIGŸí0£(Oº&’èe¢]şµ/áıÏ÷	êCÎP-v/O;*[]ÔÓ2Ù¯%æÀÄ!½£o‚±¶Ê|$ÓD	Ç|F~93c·¿÷Ttk~õ7ğñªµpç]ë%+öx|.1“ïYçN˜Gİ_;lÕ®(Fš9úN?x…ıOŠÚª“¾ßE‰iXwJò}aRHH·X‹{€"ò¯;ÍÊÉ­˜²Æú;¬~¼›öí-@Ÿ2maÎIğÿÜNüx4.öÇ¢ù–ìajc'h¦åíÃ±Ì´z*¯áiP¶›~?`®@¬4‚Çq%T2ÒÄE?£M*ôûÒã4³c¯>J)Ryen?á6*ÿwiò`ş6ß÷ñ´OÎÜñaóÖ¥ÇrŞZ09·İæaŸg1pZÚ9Á·ø­´ov£Zô&k%`>ãüa¯ÓyRkß®àVŸFãƒ¾¿
OÚ³²çë8¿6²äœ¬ÃWbÿP€Û“	¾}&²Û”_}& UÃ¨AA%öV’ x<,ÄªmÈá©]~2ÛäÓ–ìÕK€æ¬êü¦ÅÓ İqÇù˜v`òVŠ;ÊúÖìí¯$Š·V!Bé?<ùúÃ ı¢åŠrNŞöÿ–´¾HŒ›ç®=ûç‡\íMÅFFÏ=)e(>%IQ¤„=¿-±»®+˜J™QÏˆFM]zŸ{a»ñ„¼˜*w;û0o÷ùÛnÇ—°ŸÛcìîÇSlÉ‡óüâî§ Œ«2å¬„¹ULX¯9Ó/Oo'ºŸªªÒşª$œ@ÿ!öi:³*÷Ûó¦T\§§‚êrÀÎ(ë£œ¬5ş·FÈ¾°˜\$-ğüHfO˜›ŞN5‘¬È.÷Óã¿~DÜğ…˜·¹~8»ş‹‘Áã?-~/~Z¥Ø¾%Úù>‹ÒUäéĞË“p$WÈ~px¿¯ºsæ¶š
º?·áİ	ŞÃN˜´<š“1]®3%ÛQ‰UnÇrMİ*šiºŞOø—ÿÆFIºf¥
èÔ}çlÜÈÉç˜ñC¸<†á<‰‡éÚO=Š ‹'÷î,FÓ}g¤ª:êB×È{Í©Íİ9nVƒnllõî+–—–-Øp²iğ÷pô.gEåı~†ÓëÎ¢z=@òB.\é™?Ûıİ¨3s•²:5V%;5”t ôíÎ)ÔİCÿ#—ÉòojÜØ_ÙÏÉ¢¦[‡7µ3]t’=9è
R]Ë©5ß”dSr(KVêéwÿ•?°Fø­Éùc¾÷:; 7ê‹ãÙƒG‹yWÅu~/‡%NNiÆ@İBÉu	€ıS`òi&Ôî^ä6ìŒc±IÂVÚ¢%.®}ÛÎ²S"çXkMƒÑ¬tß¶çûµğ,gµ”×"ä0\ûBŒÃêqÁÃQ j|Ä8MÃæÎ{ÛŸá»Æ[ãÇ©'¬l
ošIO}Xº^ÄyÀÏ+Œ\[B®½?BT~–	W¶ o–èîÔÄğNìdl' ùCK‘ï4%èË;@ÿş&m¢c¶.;ß‚ŒcÍæ^3÷áK„ô4ê=á°0)ÿeA…#^Ë¶û3£kî«Le@)ÊùŠDª*>z†­Œ¯¸šÒ]s€q 9ª|Ãˆãµ$6›‹©=š*M«1n¾ôˆãw¡²Óù˜YyVÒ»¯ÖÑE'şe-LÚà4ıXÕù©‡ò…KŸÖP(Ø4R²iW!5 990šù„fÍœû[÷´¨* ÊH·,ƒ·êŒ~ûlÂúíşœ~»ä›­ı•ş®»3a†OçÎ÷>4™…~?v(ÁfAT¤÷÷¿–kh­
…‚ŠÍ–{¹»ĞË$±O³OşH¡ğÁZáÊš(?ÈøDî&Àëro æ,î±òVeK>èoÂ&ßë<è{ën z3!ú2&·š9¼i<ËNşüüDARsa—ÓMÿá›ÇOèúš|Ã9ñH²ùú¶~ GEjÿbôÅ†mµÓÚ\>‰¯>Åè½¼¼«âİâ·?öÚãÒ„&-mİSôq:ïî!Ã€ª1SàRõ†e´ÀÃ-â6œÄssní¶åƒ9B`‹,-
ñ¢EDpÖ3SÛVº°$AñY»N{t‹'â‚W- ¾ù–ñA¯Úç¤)*«àÉ ÙS£á¸İ£Ü8?‘ŸÕWLpMíŞ×„îîŞk\ù´¨Ü)÷ğ‘óZ[Ğ0·Î!öz	›ÓŒô×1fæ™è™`8æ¯å2
ñ<^¶V'rò_†«áxğ°
¤Õ²'øpòßhşde£çÚ×Ò~¬Ê§3Óô/E)ò«Òc×ùÏİ˜z uÄéæIj¿«*tÍïŸ·=.yŒ3pN›3ü}rš¤u ¨=C3ÔÈ/ÉeÖ¡ZÂÓ÷7ÈıÒù1ğxøO?¨g±á’^:ù¿ÈÈ]ú¨jœÙ2g×BñjYL'ùÅŸJÌF=Km3T•éà±ó¢ŠOâëıÏÏÍ½İ?åSúÓV¬±@~DŒõ¤L´*yéİlÄÅ¥q<{&³¶ü¦Ş?ãÔ=¤Ÿ+Õ¿$–™8÷³ÿ­ˆØìİ ³’‘!‚ğÖ=²û’³ã™¥ µ›3QœNÃ2[Èc·G](CT;ç‘ø†k×TëË şƒÓ×®³±½ÍC•åÀ%O‚YÍl½å®•kÑzºşÕ»Àgä»'Nú¡Ÿª¨0ö¢D¾ÿk]Ê“¢ÿß³H–‡ß—·+ZˆJşÿ
€÷Ïò\àmë¤ûúp]`_}ùğãXv!¸Láƒ>wŠ2%ÏŠ/ûîM2µz\¢ñ¿	)IiŠj“N©û.ÒmÍ¾„…˜âˆ£¿ï/jIŒ¤^ô›ËJÁd‰è€LÄãÒ"¶À¦NO‹ıµ5Óı›ø‹½P®NKaVÎ¿öîqEŞI:ëÚë1öR“ögZ´‘şeæZØñì«°°Cªƒñë8ó-‚­·˜ès5)[ÔÀ™•lj+S÷®ú“–bDŠãçÙŒQ}ïî ­7ÛüÇ·y8Ìe¡¤·¾··ÿ Á+ÎşÏCş/k¶
}p½ØĞÀíü™~Qè­™ÕŒŸ‚¿ì×H‘Át¼Œ~XN.oè‹û‚¿±T€Mûø™/ŸüÓ%¦Ÿ-P˜¯İŸ³IšâJYÁ·j#Vˆ$ıŸÃ!ps{ª!3$vƒZN™ä»È|»Ï1}Ô_MÎ©ªKÂ[ÇŸøg5„Å¶ÔırNzfñAıÊÍhÿVİèÕ—ş|òèìÊÈ§òÀóûšw$CrPPg/Ö˜täß^øëNíw#X„E!5©%Û÷O8ÿ9Ş’è÷ıËDç*[[´n:%]ÖØ( ºsázr¸zôtÄyÈ¤Åç¡ú;MËì²àL£ka?Ë›w„…s*©\Ù…ÀG%»-sßß4¬ÂÓD16î:ÚpÊ™Hgá%“ZÓIÈ§‡ßè.n¬n¡¨7zDÀ°iåè{É§õ(Ûâä ›JÖ:¢üæ}ìZÀ<w‹ ±bŸÉåİŒca¸¦¿¹BĞáü‹‘}ä¶^¨# kµâMüoâc9=s<‚æ¶"]ı¡¿:¾êR²®(¹û4”1ÖuĞ*÷Ê©`Ğ´fVG2Ü¶®°àëéçd3ÂÖj\2ãˆĞ:å!ûİrFÎòE@ñ†ósú7´lw ¨EÛRßÈ&Ê-è4µB6ÜŸcfèJôÊ59–Ğ&†èë>º»¨Y_’ES÷·} ùùô™Ãû]ÛÇÂöê-Öæ%½Ò)qzzN;È×C!óEÈ›ıìßãX„3I#¯KôXõI§hGd¬}àãñá©{Ø”Ş5Şõ‚'öTän±àä Ì¨êóºËĞx2L(-BV#ãpéPl ’½õY73 ì›
U0À£KzC†ú|ıHäş»$Ã½„sŸVNo¯ßÀ?s/Šb¶ğŸÊ¼¶
à¬püá_fµ´YNIz§yÈ™ósïdÜ¶œFC0Şÿ%ïƒ<ó=òÀ˜ Ñ‹ÓUÉİ~Ú‡x½ø¾h«|Ô5¯ê–¹÷Äûí0Lz	· }K/å~k]ø©sÌ´	­Qrúoœ»wG³¼
Rë¶Ñ€|T6¦Mpà¹ß°—T#ëQgÂ7V<`º6UÃt–]áæ‹'NÎùÿµ¥¸CD}œ,1òµ=}7Ò²ÌV}¢_ÂÂ«îP¥€±U8ƒK1E-«{I9úˆFÛod¨Ø€nq"/cÃ Ÿ4U ™!ÿ”ZîYs3<˜lËIµ9u.»ò"çxäØojÅ˜ïÍ…ôâˆIUoª´Ã½Gw°|¡ó>gÙ!Ka55öÀ²÷Á‡v{ëÿ%4¿cŠ¬²¨”ô€Ì>â…3ãîıèÁ‡{¶¿py1:`¾üè}Æ”U¦z”›W®Î`6áªËkØ†À#²hºæcİö0}m>ØrªÌNIÀ–æVoJ};Hò(
Tz4ò©sĞÏc=÷Ùâ"ÉÜŒy<”vù9ºÆØàÌT–æYL<át£f!8B8/}kå«´ gó§~}Nq²¾Û~ğÜSVOåÁítàÄôÎâ•´\2ÿÔ°²~İP¨çy‘­gã$2íuäÕæ¿¿7sûÎ>ë­Ê×í$…wÇ5Æ1t‡u§Óó;Í¹§‡ßùóÏ€ŸìánÈ:¼¢ƒ¾ƒ†ÃÚ'·çË$Ÿ)Ü¹’yÆl"^»cıÇ¾?ˆµÌ»Rf¥“¦kä9Z7?IbŠ~ÚŞ»~o—§y4ÿ¥O™YÛKïiï|œv»‘JÈÂÌUÀ›BÔŒËßŒGÜ×¡cåµB)AyYÃYÔªg 5ÌC›£¨™êà[ó˜Ñ2	Šyn™†Lf -zî“i'iÖ÷ü—Š^‰„à¯H¡Ùöë6òz	%bT$¯ÓcêgÆØdu=¶Cúıq]›K)Ÿ†&üˆÿhÓ=ª:R¾.fÈêSˆ!WÊËåÍş‹«­t²yoÒÿ¼˜÷‡skÂ]ÿÌBŸÍe‹æ‹>)­ÑÛóéo³›ÚqÃÑè©ß? W837}¡%O®nÔoŸ[¤\Ôbvòiûô@ynsîÅoL”æØúK6Êg|l'2ZµÒ±g7U]'!Z(ï×R?áÚŸß¦ÿ;Êt6—ÿïC ½¿×sZ'0ºL4±qæŞÓ°'m £y f@RwACÊ_¡s4³ğwN}îgqòÿá/MàŒ¤«Ëÿş„5Aõ—™¶ü«:™¸lu¬£yµkél4±h^gõd‹ktS7QêA„ëw‰ş¨vqxáĞ`:HºaO€OÛ™õÔd“¡ÙDúWúö|şÚ±n0¨Ja¹\îë³Ÿ4û~gbSÑ•“à’Q´TEH8àZ
á
ÅÉ<ú?‘âö_."Ñ§t~ø“ÖFŒ=‘
ÂÔ<Œ,­K+÷®Şû¸tìPH‘BGO[3ZAE“¥ÛzSz¾ü8´“IÏbÌ¡§ıàGIw½ÒÎwšKGÏQÖrE’|¦Èf±……Ñœc{ôõó¤ÍVO$edd”KX»^ÈÂ3Ï^zfAø3Õ.²ˆ´¿bêöÍ¡~˜½h©½õrñ.ƒ~KXŞí37R¸‘õQŸÒ}ıÙyªıÀ=8ü¿¶5Éc)’ó¯ş: ìÖîØöäv=c¢8&ÏÈÔÚúë* wšK'am>°—7Ğ'½ı$¢Ì¢áSÉûÛ!‡BQ´‚ËO>›KŠÓF3ÌÿRÔ9áİ™°ô‘}TàÂ¹«6Ö¬Ÿúö[,›ê©MP+–"«¶ã¥öÿ~Ô?¥‹2`„;qùé1ë2ÚÂwÛı§Ö9Ş[W€_âD£¸/ŒĞMÛ‘#+Ë)ø¾í–Zõ7SOío8›€™Ğû‘U~]¿ØZLò[Ç#‰¦i–-¬*[‰ÿ…Éhíşgs”?4%·ŒÿçœìŸŞ>ÑÕÖĞpEG'¥ááˆÛ©u„ÖÁQ¡)åq€(–øĞr-ãY—Aş™ÃcKèÅ¢¥ï#e™ädÏIÁ°“¡7±¾Êå.$½.‚Ââ\ äÌÓöGeºİ†Ã¶E
´¼ÚBµÿ³–|¿Ô¿|i‡îyl.¯ä´Z˜é°&@-êi	Ú@G×ºŠ“•çğBœX<EŸï¸n7­!ß)Åõ(°†9
ûc†ßv%şoš-›3ÏÿÚeøÑA?EÛéâ±[?8Ë’Ì×(¯•5M):«/úrÚsLˆ¤‡W¼Çvÿé<×:áúwÂGY‹?åÏèOz´'/±qÒÎP¢şÏYJ{â,ÇhèR6R6áÛ¡ìoùÄü¿;¾­©'è¯y(4œt‹|7$ˆÉpÎhÙ§3*¾ğlYe:AÂuĞõ$#5Z3ëÖä»Â¾>Áı>n£!¶ÿSm`Ş#ã.ı¾ÈÏ­gé•>ĞÚÃ³!ª@rrÕ–¤o~º®<kÜ8#&Bx½—rX!u›Š(Ñ‡¯0üL’D„è²áºÌ€â»doRà>õË’WåñŸŠ„òê.ÃÃ–¯yì@xrÎ°h†tş~âèlæõ««õéSÚoõ©]ˆCf–8âÖÉ-‰0u‚$°ÔÃõıŒrónEm×Äõ„Ÿ|íÖÔöøİ€³‘0•OıÁrù–D›ÄAšdG*€Ä˜¡ˆ|Ë•!°VW:MáI‹gc’áVsİí¶qjD/?d¶ø:¬AÕ½‡r"…çeE#töÑ¤å­4ÕN?fZ½Æ}ÛıÎ°D×½´×TååÈ‘SùrÊœf-Ÿ:¤¼áÿ¼Ş²½0¸PùÖo·íŸÖÑ°z%òŒ	%—,Ó|³8¦qQé´{YöÅÿ­~±«êÎG”,ŸøungÒ’`¤Òtã»í[á·ræ4Ùb?Ay¯`ùÖßùÎÎ]X?^“8_õ²h<¯˜…wû¿–1‘P+ó	]Šå›şïßùTµ^cqÈæLùB«HÚU¬…V´“´Py#ß~jiFgíKz<>o¸S»×[ºğ&a/†ÌUíK»è¶³vê—ÓÖı!·|w/ Ó" ¾§¹9à—´Å¤©ªîû§Î	ñÍ·}¤${F}·›5SŸ6¼±i»G¢†Ş^IÔ&©ôîıyÓ·- aºäåOau·z´¾ éS_;$}=ò¼TŒíM«¸‡Ä±''¥‘“í´Vuj·í¿ªîõf«9R£5 Ÿj·[hh	İµ¤¿£}¡¨i3Ó{—6bÏây‹ŠZç{§ìÎÜMÃ†yÀQ;ö7íßO-Éò~³Íõù*}áî•ø)ER\OPB%çç³?‚›§]eMI{Åú{K·‰1¦G½Õ@ÑÊ§¤Ûkw_aÌ[#iÏ+æ¬œÏ~^ç”Z™~m:ïf‹ØøN¥ƒÀ­s_º@
RGëöÚş˜-+ËšÉ‚ÜFÔÊ| t1-/9o*MŸ9zõ×]O7ìIiE…VÙ±™äØ,ìúãKì¶½QuH÷(nci3¬™§Û‘î®qHÂdˆHeR° @	†•Ç»°üw²š—d·»ÏdÎ ô­´¼üC	·pÌlövBuHÉÓ8ü?¶qáñĞhÖÑkõh_.ÚU‘Û;+ÛI×·İÇÊë<úß^˜5;äî7[¶_Êßéúa[Úœa;êQsõ‚×â8ÓÛVnëÚr1Ã{×.}(©¾_l®Æ€½MçšÏÙ½ æÂt†å)Ğï})ÑaóOk5œÿ·šŒÑNŸ^ni<UïE8&¾/9+¯À	LŠ¬Òj
&Grî‰h+°7U+màÖ³ãv’š …VïñÊên¿}ïø®ÃŞÈ½¯òzÔÅè>ñzšÅ¢Û%«ÿs0ûúw.¦ÛÇa­G)Í:šW€Şü«Ñ~4ŒÿöÊëÑĞ–f–ïmûÖM¾¦êûÿå°Nßµ_œİGziúÙk\QÎïl÷‘ƒ®îo5GkM{sS´²½ VÆŸu[:åR&£‰[i§eïëğ¯á_÷ü­.4»“ô¶×;v½SÌRåÓ`ÿWĞ^_öûÇß×mEãÌÑ=%ıòbÏ8S¼²ŠëV˜À<´q·‰Q„TÇyu¸+÷Mç™GâQFc,×·àÒËœ¿î¥j¡ŒZõÙ‘Ì?½i—½TNœ&,kŞ·xù