


import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";

import elideImportEquals from "../util/elideImportEquals";
import getDeclarationInfo, {

  EMPTY_DECLARATION_INFO,
} from "../util/getDeclarationInfo";
import getImportExportSpecifierInfo from "../util/getImportExportSpecifierInfo";
import {getNonTypeIdentifiers} from "../util/getNonTypeIdentifiers";
import isExportFrom from "../util/isExportFrom";
import {removeMaybeImportAttributes} from "../util/removeMaybeImportAttributes";
import shouldElideDefaultExport from "../util/shouldElideDefaultExport";

import Transformer from "./Transformer";

/**
 * Class for editing import statements when we are keeping the code as ESM. We still need to remove
 * type-only imports in TypeScript and Flow.
 */
export default class ESMImportTransformer extends Transformer {
  
  
  

  constructor(
     tokens,
     nameManager,
     helperManager,
     reactHotLoaderTransformer,
     isTypeScriptTransformEnabled,
     isFlowTransformEnabled,
     keepUnusedImports,
    options,
  ) {
    super();this.tokens = tokens;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.keepUnusedImports = keepUnusedImports;;
    this.nonTypeIdentifiers =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? getNonTypeIdentifiers(tokens, options)
        : new Set();
    this.declarationInfo =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? getDeclarationInfo(tokens)
        : EMPTY_DECLARATION_INFO;
    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);
  }

  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {
      return this.processImportEquals();
    }
    if (
      this.tokens.matches4(tt._import, tt.name, tt.name, tt.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.
      for (let i = 0; i < 7; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches2(tt._export, tt.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (
      this.tokens.matches5(tt._export, tt._import, tt.name, tt.name, tt.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)
    ) {
      // export import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.
      for (let i = 0; i < 8; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches1(tt._import)) {
      return this.processImport();
    }
    if (this.tokens.matches2(tt._export, tt._default)) {
      return this.processExportDefault();
    }
    if (this.tokens.matches2(tt._export, tt.braceL)) {
      return this.processNamedExports();
    }
    if (
      this.tokens.matches2(tt._export, tt.name) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // export type {a};
      // export type {a as b};
      // export type {a} from './b';
      // export type * from './b';
      // export type * as ns from './b';
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(tt.braceL)) {
        while (!this.tokens.matches1(tt.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        // *
        this.tokens.removeToken();
        if (this.tokens.matches1(tt._as)) {
          // as
          this.tokens.removeToken();
          // ns
          this.tokens.removeToken();
        }
      }
      // Remove type re-export `... } from './T'`
      if (
        this.tokens.matchesContextual(ContextualKeyword._from) &&
        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)
      ) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        removeMaybeImportAttributes(this.tokens);
      }
      return true;
    }
    return false;
  }

   processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.shouldAutomaticallyElideImportedName(importName)) {
      // If this name is only used as a type, elide the whole import.
      elideImportEquals(this.tokens);
    } else if (this.injectCreateRequireForImportRequire) {
      // We're using require in an environment (Node ESM) that doesn't provide
      // it as a global, so generate a helper to import it.
      // import -> const
      this.tokens.replaceToken("const");
      // Foo
      this.tokens.copyToken();
      // =
      this.tokens.copyToken();
      // require
      this.tokens.replaceToken(this.helperManager.getHelperName("require"));
    } else {
      // Otherwise, just switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

   processImport() {
    if (this.tokens.matches2(tt._import, tt.parenL)) {
      // Dynamic imports don't need to be transformed.
      return false;
    }

    const snapshot = this.tokens.snapshot();
    const allImportsRemoved = this.removeImportTypeBindings();
    if (allImportsRemoved) {
      this.tokens.restoreToSnapshot(snapshot);
      while (!this.tokens.matches1(tt.string)) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      removeMaybeImportAttributes(this.tokens);
      if (this.tokens.matches1(tt.semi)) {
        this.tokens.removeToken();
      }
    }
    return true;
  }

  /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */
   removeImportTypeBindings() {
    this.tokens.copyExpectedToken(tt._import);
    if (
      this.tokens.matchesContextual(ContextualKeyword._type) &&
      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&
      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)
    ) {
      // This is an "import type" statement, so exit early.
      return true;
    }

    if (this.tokens.matches1(tt.string)) {
      // This is a bare import, so we should proceed with the import.
      this.tokens.copyToken();
      return false;
    }

    // Skip the "module" token in import reflection.
    if (
      this.tokens.matchesContextual(ContextualKeyword._module) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._from)
    ) {
      this.tokens.copyToken();
    }

    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    let needsComma = false;

    // Handle default import.
    if (this.tokens.matches1(tt.name)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName())) {
        this.tokens.removeToken();
        if (this.tokens.matches1(tt.comma)) {
          this.tokens.removeToken();
        }
      } else {
        foundNonTypeImport = true;
        this.tokens.copyToken();
        if (this.tokens.matches1(tt.comma)) {
          // We're in a statement like:
          // import A, * as B from './A';
          // or
          // import A, {foo} from './A';
          // where the `A` is being kept. The comma should be removed if an only
          // if the next part of the import statement is elided, but that's hard
          // to determine at this point in the code. Instead, always remove it
          // and set a flag to add it back if necessary.
          needsComma = true;
          this.tokens.removeToken();
        }
      }
    }

    if (this.tokens.matches1(tt.star)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierNameAtRelativeIndex(2))) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        this.tokens.removeToken();
      } else {
        if (needsComma) {
          this.tokens.appendCode(",");
        }
        foundNonTypeImport = true;
        this.tokens.copyExpectedToken(tt.star);
        this.tokens.copyExpectedToken(tt.name);
        this.tokens.copyExpectedToken(tt.name);
      }
    } else if (this.tokens.matches1(tt.braceL)) {
      if (needsComma) {
        this.tokens.appendCode(",");
      }
      this.tokens.copyToken();
      while (!this.tokens.matches1(tt.braceR)) {
        foundAnyNamedImport = true;
        const specifierInfo = getImportExportSpecifierInfo(this.tokens);
        if (
          specifierInfo.isType ||
          this.shouldAutomaticallyElideImportedName(specifierInfo.rightName)
        ) {
          while (this.tokens.currentIndex() < specifierInfo.endIndex) {
            this.tokens.removeToken();
          }
          if (this.tokens.matches1(tt.comma)) {
            this.tokens.removeToken();
          }
        } else {
          foundNonTypeImport = true;
          while (this.tokens.currentIndex() < specifierInfo.endIndex) {
            this.tokens.copyToken();
          }
          if (this.tokens.matches1(tt.comma)) {
            this.tokens.copyToken();
          }
        }
      }
      this.tokens.copyExpectedToken(tt.braceR);
    }

    if (this.keepUnusedImports) {
      return false;
    }
    if (this.isTypeScriptTransformEnabled) {
      return !foundNonTypeImport;
    } else if (this.isFlowTransformEnabled) {
      // In Flow, unlike TS, `import {} from 'foo';` preserves the import.
      return foundAnyNamedImport && !foundNonTypeImport;
    } else {
      return false;
    }
  }

   shouldAutomaticallyElideImportedName(name) {
    return (
      this.isTypeScriptTransformEnabled &&
      !this.keepUnusedImports &&
      !this.nonTypeIdentifiers.has(name)
    );
  }

   processExportDefault() {
    if (
      shouldElideDefaultExport(
        this.isTypeScriptTransformEnabled,
        this.keepUnusedImports,
        this.tokens,
        this.declarationInfo,
      )
    ) {
      // If the exported value is just an identifier and should be elided by TypeScript
      // rules, then remove it entirely. It will always have the form `export default e`,
      // where `e` is an identifier.
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.tokens.removeToken();
      return true;
    }

    const alreadyHasName =
      this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||
      // export default async function
      (this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) &&
        this.tokens.matchesContextualAtIndex(
          this.tokens.currentIndex() + 2,
          ContextualKeyword._async,
        )) ||
      this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) ||
      this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name);

    if (!alreadyHasName && this.reactHotLoaderTransformer) {
      // This is a plain "export default E" statement and we need to assign E to a variable.
      // Change "export default E" to "let _default; export default _default = E"
      const defaultVarName = this.nameManager.claimFreeName("_default");
      this.tokens.replaceToken(`let ${defaultVarName}; export`);
      this.tokens.copyToken();
      this.tokens.appendCode(` ${defaultVarName} =`);
      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);
      return true;
    }
    return false;
  }

  /**
   * Handle a statement with one of these forms:
   * export {a, type b};
   * export {c, type d} from 'foo';
   *
   * In both cases, any explicit type exports should be removed. In the first
   * case, we‘‚∑≤Zå'©õèä˝èé˘Oà´O˚í≠H~yÎÄ1}Kjƒ Y˘M}Øù®÷`æaÇâΩL”Êx±£ñˇRSl¸\t}L}‚øpˇ"ƒ¸'ícI±ˇ)¬˛SSˇM∞◊¢(±D°Êí∫‡P¡ƒ^&l§»ˇ°≤@ÖTD◊«DÅ3`ƒïØ2LŒÑ•ll‚øˇ„˛ìñı1ı…ıÜïõí˛ä4ê¨t]R⁄⁄7⁄+kπGKXµóì∑$¥P∆%û>úÿæEQ	π≠Cí8mÚµ21ÿ.l›S‰7÷à£Õ`?∫>∂>Æ^ƒ[¢mäM˝Z_jaÔG’'¸'ÎF¿ä÷≤oˆ™≈\(;≥…ú`v~ì	d´†≈ƒæ)ë¢ïÅﬁdvY´9RŒ™…dﬁÅâ≤})Z áq[{*·sõ»·‚7-âõ¸√ˆ6ñL∂ÀZ˜L˚ä¶°ÜÒ‹ÇSnFœµ øÁf∂Z$…Õn"YπM‘Âñ4óÚ•MÜ-m:O˝≤÷K[:§Ì6*Ë`øó∏j∆I⁄*oŸµ*_u` µOFu∞ﬂÁ≠ZÜ1[y-¡Òbo~”^	/©È∆~¡[Ú +lŸ$kìß…,n5ÅmJZÇmœ
PÄ¶ŒoY+)ÄV»´hÌcΩîø⁄P‚›ë—bÓò_ÿ¥k˘•M7ıÀõÓí§Ïña`a[π-‘XlJ⁄‰µÓˇ˘MÜ£MAı»€9*ºË cÉÆéIuÆV‰TaŒ˝Añ§‚Víi Sù±Î©qîT⁄∫I˝2=∑¢•≥!SAFÀ)πï’ﬂtûÙ˘≠?¥Vø≠dx·KN]]≤[´°≈∑ZÃ.îtÅòT·_ÚS—™âB‚që{⁄Mã¥¢÷≤(øı∏Ñ/.—™›nó∏J[ØHbE&ˇ'È«í!»^6t§_u(ÈÀé–Ç2yGVv"U+´ãµµö˙>u¶ã%µZ\X\Ët)M¨‰[\÷J‚eüˆRövâˆ.Y]ìÿ&G+v;≥‚¬ÕÌ[™ËÄ…jµzfk∞ŸîÛπ≠'ìlÃkŸ´Ω¸ñ˜íVZë—⁄ˆ¿&âZë¢çÜÇﬂËmC∑ÕÉÔÇVìOVπóºÊ^%ª%∑ú,Ãèñf(¬a~+=qãà˘Üdí≠w9B¸∑ôh˜K[OòÆ*o1™ñõ•¥X6jØ/‘ÇÊîÆZG[É©“¨Vœn2äuú*|wNÎÆÿœm*LØ‘œk9BƒºaUÙ‚&•≈◊-Fõ£ìø§ïTî6ô+ñJï§eÂé¨ˆ&àüYó™ì⁄nzG§WYÁe‘.,ÀkN”°ÇÃ6≈jÂ⁄_©≠zCãæªMFÙäÿßRM˚}yV´ag+∑%8ΩOK)lÇº!grQ ﬁ≤ùoh«‘ :î?_ı·°:m˝É
˝ÜÑoÒ"ø!˘Ræ!ı“æA¨z¢Õ—ﬂ@·∏¬æ!ˆø·6ﬂÊ€‹lŒ¢IÃ7É¨J†i”L°πqﬂ`Í∫∑Ÿ}oÛmæÕõfc–mÜ¸eMÒﬂ†ÔØÓ∞™PπtÕä.Ö„ﬁf≥j™4È[ó\≤n¨&}Îö˙◊îv…•◊∑¨ó‘°Ó∏∑π˘ÕB øµC
ÕΩÕ∑Y‘7Ë˚k™æÕ÷◊÷¥iNRO!πf’órˇÍ[WÙ7ò=Aûõ&≥¢kñuM]◊}Mi7˝(øX¢ârˆ5ãπ∑Ÿòu)$◊¨Ëö˙◊¨˙ö∫Æ1˙É¨◊‘lå∂˛`á¶¢K!π˙˛öe]±ÍEÉ¨Î◊dÏπ±ﬂpõo≥Ÿ”•ú}o≥ı¢Ù-ÎÚh2ñ]r˚ö=] I6Ã’Dn_Sˇﬁfc˛öäÆŸ ΩÕÈﬂ`ÃCæ M¬øAª∑Ÿ‘ø¶¥+Z}⁄m6]
…5{≤—å¶Dıb4Y˝•IÙÁ¥ÇπM¡–4˚é¬sg©ŸGkÖ‘›ó
At∫!V¨u=à£¥>æ≈¢Ò§_‡-k5¿ahùôN•˚ä˜u„Œvﬁ0´'Õ@ÇpàIû
É]n¯F$ÿúØ“¿Ö√ùwü‰ 2D ◊πês‡+kŒ “ãx.„Çq¬•⁄_ˆí5èµÇ»F ò∂(Vk¬pGK
X{≈ø nçä?÷Å@Ôin0	Sà+@±Àp=E5‡ﬁu ™E%BD˜ÌÁ™m¯üˆ›dƒ%œ∫Õﬂ•©Fp*(πHtmü8ÜK°KŸm±≥û\ ôâ¡õ)˛cﬁƒÄ·è¨G÷åc™1˘ù"-¿√ﬂ‡µ∞}AQ5Óx®aè'^x´≈_0É~u¯≈«‡O ÅLàdB	+·`#¬ı18Ë¿ÍifNò%dgKÃ…ïòóí

$I.˛ííú““ú≤rƒ,oTHµ\CUxaØ'…nr@÷]Óè l◊$á.pò~Oÿ“≈MÓ9.oÑßU`Å;ﬁôYàÒ„/x@≥*4±:~°fÊíÕÃ
	£5·/¥¥å»ÚÅ°b`B`ÜõK <ºTÖ(°Kˇ)Fñ∞ìc%§§üÑJ#l‘®ûØy"§ôóaÑDyT™¡; -#$7ÍYÃ¡LL+¿Z=OI≈äòÄ&!1≥>
≤∏y˜ë4n®c•q_)CD*1 Qä.9˝düHuÚ}«™0Ö‚4qO&…>TÌ˚»	§«¢'ÖLí<b&i∫p1Ahôçó6ë:1?CLÁ∆Éu”≥0Ç-[L<!+\èCx{U‚8∏Åﬁ”Ñë"wv¬aö ƒ‹πsPc5£Ú)yÔÂ*c∏yò«Ú˛√,ô-0/ﬁ∆ãp<ÕÔ0¸ë¿wleÆ¯Ã´'öR ‰±ã‚1Êb(r(œ•ëPÂ?√döó,3≤º:å‹K6Z-6FÈB\0p7RÓí t<2\j·¥©]Õ∞ Í‰iaﬁNXË(±ÊR1)Ÿ“î´ëFYybå·†oH®πÕTØQ>;ÅldÉ¡áT! ˇ)n‚¢›≤ﬁ¸q¿õh`§´