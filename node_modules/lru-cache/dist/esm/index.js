/**
 * @module LRUCache
 */
const perf = typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
    ? performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ? process : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
        ? PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const TYPE = Symbol('type');
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
            ? Uint16Array
            : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                    ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * All properties from the options object (with the exception of
 * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as
 * normal public members. (`max` and `maxBase` are read-only getters.)
 * Changing any of these will alter the defaults for subsequent method calls,
 * but is otherwise safe.
 */
export class LRUCache {
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (fetchMethod !== undefined &&
            typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0
                ? ttlResolution
                : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the remaining TTL time for a given entry key
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.delete(this.#keyList[index]);
                    }
                }, ttl + 1);
                // unref() not supported on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
        };
        this.#updateItemAge = index => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
            if (ttls[index]) {
                const ttl = ttls[index];
                const start = starts[index];
                /* c8 ignore next */
                if (!ttl || !start)
                    return;
                status.ttl = ttl;
                status.start = start;
                status.now = cachedNow || getNow();
                const age = status.now - start;
                status.remainingTTL = ttl - age;
            }
        };
        // debounce calls to perf.now() to 1s so we're not hitting
        // that costly call repeatedly.
        let cachedNow = 0;
        const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
                cachedNow = n;
                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
                // not available on all platforms
                /* c8 ignore start */
                if (t.unref) {
                    t.unref();
                }
                /* c8 ignore stop */
            }
            return n;
        };
        this.getRemainingTTL = key => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
                return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
                return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
        };
        this.#isStale = index => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => { };
    #statusTTL = () => { };
    #setItemTTL = () => { };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = index => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
            // provisionally accept background fetches.
            // actual value size will be checked when they return.
            if (this.#isBackgroundFetch(v)) {
                return 0;
            }
            if (!isPosInt(size)) {
                if (sizeCalculation) {
                    if (typeof sizeCalculation !== 'function') {
                        throw new TypeError('sizeCalculation must be a function');
                    }
                    size = sizeCalculation(v, k);
                    if (!isPosInt(size)) {
                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');
                    }
                }
                else {
                    throw new TypeError('invalid size value (must be positive integer). ' +
                        'When maxSize or maxEntrySize is used, sizeCalculation ' +
                        'or size must be set.');
                }
            }
            return size;
        };
        this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
                const maxSize = this.#maxSize - sizes[index];
                while (this.#calculatedSize > maxSize) {
                    this.#evict(true);
                }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
                status.entrySize = size;
                status.totalCalculatedSize = this.#calculatedSize;
            }
        };
    }
    #removeItemSize = _i => { };
    #addItemSize = (_i, _s, _st) => { };
    #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');
        }
        return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#tail; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#head) {
                    break;
                }
                else {
                    i = this.#prev[i];
                }
            }
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
            for (let i = this.#head; true;) {
                if (!this.#isValidIndex(i)) {
                    break;
                }
                if (allowStale || !this.#isStale(i)) {
                    yield i;
                }
                if (i === this.#tail) {
                    break;
                }
                else {
                    i = this.#next[i];
                }
            }
        }
    }
    #isValidIndex(index) {
        return (index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index);
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
        for (const i of this.#indexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
        for (const i of this.#rindexes()) {
            if (this.#valList[i] !== undefined &&
                this.#keyList[i] !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield [this.#keyList[i], this.#valList[i]];
            }
        }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
        for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
        for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield k;
            }
        }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined &&
                !this.#isBackgroundFetch(this.#valList[i])) {
                yield this.#valList[i];
            }
        }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
     * A String value that is used in the creation of the default string description of an object.
     * Called by the built-in method Object.prototype.toString.
     */
    [Symbol.toStringTag] = 'LRUCache';
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to Array.find().  fn is called as fn(value, key, cache).
     */
    find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            if (fn(value, this.#keyList[i], this)) {
                return this.get(this.#keyList[i], getOptions);
            }
        }
    }
    /**
     * Call the supplied function on each item in the cache, in order from
     * most recently used to least recently used.  fn is called as
     * fn(value, key, cache).  Does not update age or recenty of use.
     * Does not iterate over stale values.
     */
    forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
                ? v.__staleWhileFetching
                : v;
            if (value === undefined)
                continue;
            fn.call(thisp, value, this.#keyList[i], this);
        }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
                this.delete(this.#keyList[i]);
                deleted = true;
            }
        }
        return deleted;
 µ“ÊÛ‰Z)] êÓäÄ‹TŞı¼qÜÊš=DšZ¿Py¯f¿.İÃHß`ÊOÔ.“~Íş$ãxu ôÁ|¼Z-fXŸóG5]&*Q©•ø ñÎÓÅë³WÓí§ŠqõÙ‹XŸ|’¯ÏCÔ{Â¸>Ï/Æõy¨>ïç*æ’~‡JİÏ7Ôç»@ùuó—ıb±B©|Ñ¸}–AÅùq7DåEY¥ò`•
‰*µ-N~§t“~Óô¹¿6×â7D¿6ïW¿òı&ß¥>ëãúÜ”îÙm\ŸÿKŠßİ|¿JÔßÚz ùÍ³œôOv¼Iü|UîrS¾K¤?‡ê§ïa‹ãÈ?É?>Šçq4¼Dı@Ô©ÕKñ+iı°“ô¯ŸE’¨œ~ş“>£¸"yÄüö6éYGü»Tn#Õã¡öLvn!¿m#í øü„Ê}ÊûÅ¡µC7/z2)}ù‹òéç¿ õ·_³?b~£ô‘Ô~¢ÑD÷’|õÿ—çãÌCşö¢öï¿@vE“ÿ’])ßã¸ô£~!=®úäÇ¦DíÍ(½Ù×Šì!;Ÿ §Rß@ªµ;‰×«Õïj@òÕÆãBÈ ?-ÒÍ7£)nˆú‰ŠcŒ©Õ„ŠTNˆ/aØßúù×ÙYÍ§ŸïıJÚïˆUÓõóo ®„a¼Õt¡µJıUT*>@|m•újPù6*uÄÛ/”SÓİ¤Ç_]¥.*/ˆ*õÔ#9QKCÊ×Œô6§|ÅÛ)¨ó±K 9Q¯f—n|	yj~¾J¥[Dµ~Ñ3)G•{ãûÍr‘Ö‡]DMüéßKò}´uî'ıD-(h€¨ëk•:=IëÕ)•úNSúÏTîÒó+µï ­[^ãõUÚNòÅ¹x±vWÛ#ut,¥ÚOÔNÔOrKò{5=@ÔAÔ«ÉMÎÁó
éz’?Û«å-¤ÇE¼‡ä¢¾vdÉ]Ä{»­^w/ŠG¢®¶jy™ôx'ü¬_—¯’Ÿ“²Éß_ë”¦‡¨•¨DÔOT¤òN-‰—æß2)²(^–P½¯Sú2Š“7)ÿJâçR>“¸•©ß|³©ñÊï ú$J·µx™eo®t5İ“¡‹7j¶³hú(İoÜõÇ¥²É<fv~+*ÒÛïœIıYÄı¬“ô8ãŒãÎ;ü8ƒÆláñf1‰7_œq¼iıèMqiÒ_Z¼Ø‰êãEœb/Á~{Ù¸¿Ü“)^_æãE&}ZœèûÍeb§$éM~Kãd<Åß:Œ4¶Ç“BùFêì¹ËyC›gşíyÃì\ä`GZ=fñ$v5^Oå'MâR[uûä@Gò‹6èÖ[«•ìïFıÛÖ)-uë­¥ÅÇã4?˜ìWüÒù­õ²#êkLr³q}ÆQQWòË’ÿMóĞMo·É¿´?+Fí)AûŠ’di¢åˆV&»¢©]¿Ÿ›½—h_÷¿os2l‡~Ÿh¹ÅïıÄ;nšìhÜÜ)ÁÇ1Õç$ê-FüOÔŸÄG¬§i%¹~ş‘OÒ¼ğ#Í;&ír¼CvÑ>Éş=é¥ô Qaß^ÏTä®cÆíö%}oóívSy'Õç,flŸo?É¿¢ú¿¡yñ Õ{ˆÚç#;Ğ:³ßØû>JßÏÛc§ş±“â=»Hÿnª—ä¢&'Şı9ÕkÒ}?Ş/Z?û>àûÙï5n—°Õ¸Ÿıd§Hz„"ÆÁ¶ïmcû,ïÿÏÚÜGŞÅ¾àü|û¼ëMâT·ouişÕÍ¿îµ4şµøÑÍ·®7È.jŸ~—}hß±Šâi5Ñ×iß`_®QT¨e4ÙCÔ7ÒSI_¥¿Hı÷2Ù§;¿KÓÉi”ÏI~˜Aéd¯H¼o¤Éü÷4£¾­ûÓÕRMw´6îÏˆû·ÖÆıêzŒæÕf*uµ6î?kYÿDDİDıD-•£¸xÒ¨ŞÍê4??¤R¹ÑºD%»ˆ:ë“}´îùRı¥£ûÕEv–Œâú5@íÄ’†íÕ¯gJrãF»w¶SzÄ9ö!5]ïá«Q´ú,ÕøúüÄ;ª×ç}êÓ¯ŸµHnıóF©éâÃ*x.Cıâ&{õû-« ¦%Tê¢|Áx+Mö–¥zÊ“¼<ŸO¾I~¸Mqõ±½Ñz’Oó!Q¹µ[;§Õ¥zÉşˆuè$Åõ‹¨ùƒ¨ğ‹*÷§8ÖúG·ÿNPÜQ¹ˆsÕoû?@éZÆı øñuªÏuÆÁû4~6ö“åuU.jR;k«Ô<Š£Ò%òQ7QQïïT/Qù2¥_!=9Æş³Pº3‘‡"Ù!’ß4ÿ	5
÷Ÿ¯ˆşóŞÅš…ûÏûPáşs›øO¬ÉûÏ©óŸæ7ºLüç=ÎûÏzÿyüä—ŒıàùŞØ2é³êü Õ›8‰÷Ó}›O÷pOĞ½˜¤R'Qoãş÷hõ‰Æıï×ä&ó—‡úÁOT&="å÷ùh8Lı\ÓØOÁyÈdóÅ÷¿ô0ßÿÂ×—‡¢8}Áyğ¨qºÿ€±ÄÆşêPÜÔæıãÒüDí—¨ı~¢ŞO(>>£ùŒÒj‡OkÏä—/É.JwhşÓúûc²Kë/ª×Oq./§~§tıyÁî!ù&J×Æ±nœ{ß ZÓxœ;µñ`_õK –I|Qû$*ï£z\Z¿-¥qDvĞ8%xØ8.]º¸´“~™òÛuãŞm—©Lâ2b^'»íd·cùé]šß#ûIo`£q\º²Mâr1ù/›KÕïĞÍİ¼a‰¥ûj¢¢ÖÎ<Î&ãŞNãÀc¶o!¹\Ó¸ß„—ø~³ëæSÉ}D-/S\NåûKšl2¿¾Hå'ñı$‘¾@¾ŸüDïú<À„zîÒOî»ô“dÒOúø²èúIN¥~!*3Y÷Æó™›êwéúCkWD¿Ê&zt÷‹šÀX¢úsL2÷á4^FĞüòÅÕH¢I%íğ£r$Ó©>ıùÊ3ê3±GlIq@Ô•@óOkª§/ÙMıCéÆÆö	(óöY|ÿú'Ûã@şHş~‘Ê•¨œ7Í¸~q<ÕŸÆ×ï™GzæS{‰
(ÿİºF¼›¨‡¨—¨”U’ó»›xßë¤Ÿh€hpÜî¢ç€©ô¼xßl*GT˜KõÎ¡z‰wR;„â‰šéı·ãÙõ:ï'³öı8…äSi½Iı’N<Qûê’»)İ›Î—…Éä¢~¢ÒKÔî—´ù’ú‰¨¨vŞó¼e<.‹É¢^Êç~Ë8.])¨_Ëÿ&ï_ñMã¸”ß roğqéÛalŸ¼‘ìÚab&'øôxhüµl";·RÿiåŞ3±“ÒõÏ=<šºyÚEéN¢ò:j'Q·‰ı–õ”NrïZc{ükÈÏkuãyÕc¢?bZm2_Qº{µN?íÜ¹¿De¢â%*GTüìùô\¦tÊï;OéD]Dí¿’œ¨Ÿ¨ã"ù!‡òQ~÷)â‰ÊD…Óï§uñx†ú—¨üÉÏR9?ÙCT>Gò_¨QQ«§r)ÃşvÜ øú›òİ¦öŞ!şOãş·\£öçñı/ï ÷ô÷º4¿‘<âş±½÷ Éõ÷¹MèıˆÇJqı%P9çãÆí”ª‘^¢êdQÇƒ$¯Izj‘şÚÄW-eØÒ½´ï¼¯×w;ÿz»~şÕöÁ.âµõÊG¼Ğ‰Ò;ñû`‰¨‡ê1«ßşDáõû‡÷¿óiÚ÷¥~nÜßş>dåz’şÆı(w§ü=ø~”Síğ¥v¤šø;¥çw'ñö1ÄõŒ0¶G tk
oïŠ¢¾YDwò¼ë3Š«—©ŞOIßD’ïĞñÛ¨ß§R}[èäc²sñä7ÏÛ?¤rïOÔòÙµü0™Ê½ÃóÂzŞÀŞ~Ëj¾}–U¼Ü·‚ç¥å<ïyƒçÅe¤'›âéu÷-æÛ'-âËû_áyy¡N¾@×ÿ™|ÿzæñr—÷ÏáÛë™ÅÛHçûË>SÇ;uõMÕÙó2ßÿ¾I|y¨×Kr¢~¢Š'ÅY€â/@rö‘¢^Š7‘xm_h%^¦xğS¼ˆP=W^Š7?Å£—âÓKqë¥q¨ícD­id—Öj¯e
å›F”úËIıèÒü>›Ú3—ê×üDş²¨ù_p‘œâÅOñä¡ø’(î|2Åi€â×é&»)ŞÅµTÆ‡ƒúW
Ğ8<Fù¯’İDe¢Ú¼-P>‹–Ÿ¨O—/@éŞÃ”ï8ÙE¼åªç_.HPıDD-'ùüòQ¾ñãzäÿÍzüG
¯Çû=õÃ÷ÆõÈ”î êÒòàítäëñæë	~/Ì¤=Áı¦.¿¾=úz¤~÷¨vµW©ÿY•ú(]ê¯RQm¿ĞñfÔİÏç!^èHõ¶S©›¨—¨¨}ñD-š$—ˆ·tP©HÔNÔMõûKRyY«¯µ¯3ŸÏKvS½Şwur:7šÙé£ü­Üq²—¨Uã¿£öø¨œÖoÄû÷Sû’ßŞCqAıø½ÎßûÅIzÄ?Ioş=\œÜzóørâİDDDe¢–”ï/jQ÷	ÒC4 =$ˆJD=•Qû±†JÅ‡U *>H<QG•JuUê§v;‰zˆº®’½d§HT"*?¢–·Ô#ıd‹¨WãIŸEËŸKr¢.j§“¨LåTÎJ¼¿ZŞÛ˜ÚÕL¥®V*•Û¨Ô×òu$ú„J’J­(ô;4?hv^+­æ¿®Rk^ijÑüÒ\ü8şæùÿ·i ïÿ.{ôÔq™ÿ#õØÉ¯Q+QçeŠ'Š+‡6ˆŠ¹jÿIDe¢N^¦8 ê!*ı¡RQñ
å'ê¦ò¢KT¨ø›JıD¿S~¢Î€J½DíÚ¼Aq+oıšôR©åµãÙ}’ì<EzÏP¼œ¥zÏQùódQûÒ§Õ£õó%šˆÊS–Ró÷~¢v¢®²Ä×"½µ©}uÈ>íŞµåoDòÆ||KmHŞôÅS¿u§öØIÊ7€øÁÔ¾DÒ—L~zü9’ü1ŠúoÙ5–Ê¥’ş	D_¢ú§M×ÚAùçR, ú²¨Ÿ_¡ü.ªgÉSıÙÔ%d÷Dİdç[d÷â×QşõT~Õ{“æÛâÄ7§şxÊo¤ò*·…ÒÉŸùÓê¥ô]TO4å¯Håw};‰>Dù?¥~úœÚıõKJÿ‘Ægş[‡åãÿmş¯ÏÙşo¡ò´²ª_ˆJDíDµ}„H¼ õî/Eâİ©Tø›ö7i¼C<QŸÆ¢¢êj=âƒdQOM²ëa•:E•
uH^—øz”ïQJ'*ÖW©_£Tên¨Ro#¢©Q=V•úš©ÔÑ‚ú«%Ù×ŠêkMõ<®Ò QGÊ×–äí(½=¥w ¾#ÕCÔ%‘¼ÙÑ™ÒMap.get(k);
        if (index === undefined) {
            // addition
            index = (this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                    ? this.#free.pop()
                    : this.#size === this.#max
                        ? this.#evict(false)
                        : this.#size);
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status)
                status.set = 'add';
            noUpdateTTL = false;
        }
        else {
            // update
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                    oldVal.__abortController.abort(new Error('replaced'));
                    const { __staleWhileFetching: s } = oldVal;
                    if (s !== undefined && !noDisposeOnSet) {
                        if (this.#hasDispose) {
                            this.#dispose?.(s, k, 'set');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([s, k, 'set']);
                        }
                    }
                }
                else if (!noDisposeOnSet) {
                    if (this.#hasDispose) {
                        this.#dispose?.(oldVal, k, 'set');
                    }
                    if (this.#hasDisposeAfter) {
                        this.#disposed?.push([oldVal, k, 'set']);
                    }
                }
                this.#removeItemSize(index);
                this.#addItemSize(index, size, status);
                this.#valList[index] = v;
                if (status) {
                    status.set = 'replace';
                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)
                        ? oldVal.__staleWhileFetching
                        : oldVal;
                    if (oldValue !== undefined)
                        status.oldValue = oldValue;
                }
            }
            else if (status) {
                status.set = 'update';
            }
        }
        if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
        }
        if (this.#ttls) {
            if (!noUpdateTTL) {
                this.#setItemTTL(index, ttl, start);
            }
            if (status)
                this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
        try {
            while (this.#size) {
                const val = this.#valList[this.#head];
                this.#evict(true);
                if (this.#isBackgroundFetch(val)) {
                    if (val.__staleWhileFetching) {
                        return val.__staleWhileFetching;
                    }
                }
                else if (val !== undefined) {
                    return val;
                }
            }
        }
        finally {
            if (this.#hasDisposeAfter && this.#disposed) {
                const dt = this.#disposed;
                let task;
                while ((task = dt?.shift())) {
                    this.#disposeAfter?.(...task);
                }
            }
        }
    }
    #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFe|ï¤6¯DÄ¹¼¸K“{F1Ùz7ŠÉú]QjêÂôqªT|Â"zì¢ç%‹?’µ2×'ª‰hX‡z·iDS<‰ö6Ùç!…@ğ¤Z @¶ ´`*0=éQä{Z~ ëE
ãµñÁÎíø‹6Ê{è('îÂQæüÂ¿ÚÀ1>Ñl˜?­½)79°NzMJShµzÏ°(Ñ“j£e˜å¡ÙDIƒÔ0ned…šæ­¬Rüëwékc?Ç’Ó $t¼PêÀ\)Ñó€è™F´¤:1¶öyìy×887©çÑúM¥°îMf{rÚ·Yİ¨`ŞG/¨)OsV&l#ş˜G¿ø@bó1×°Ş¶]d€¿ :§»(ÁéŞ–@¢9GDóq¤;™­à…¬×)6Jİa¨&@Ö†`â ãÈ4­4!ø5İ¶Ø¸	~m'<d7'ø‚¢8=WwC¿7`w>‘­íNÑ¾Å59Ã~Ø2Şá,	äocĞKJ{ë¾4ï@›HK_eàñx,ˆŠÆn(É-ÚÈíäX¼“oèãÌˆ›¨nİhD©Hİ¬-¶N‚aĞzº^cQ]M†58:Æ)5S@ÄIšT!SL—£áÄuÇ\ØÃ¬çñÜÍûK 9ÀÉmı8¬t|?]G"È@…‹‡@¸‚MN§t¼(ÉaÿdÁ›8=í2m¹+„«(©«Í~w`…Š5yfZ$ĞşÈ‹ZÅnÁ;Ş"Øw=è	Ş±6(;yV=áÒç¿ ¯ı«&Sn/¸rÅİªïW¯XçÒzË½Roÿ“ÙÆì§=L”j\—üw8¥‚ÓŞÇu&@†ş'¸g=‰€ˆ•sÉéjƒxû{Eé´:[ím²JØ*T@#úñÃ„iXx-ívı ì¾K’‹6ô†ŞöÃÖğŒ'cHƒd¢o¶GBúş‹ğq§´[İTPËi?ãº#ÍÛ‡q?–Q<$×Î†‘w«“(½äÉæ¢t_št“H?¾IŠBppZğğWâ‘Œ|áQŒ{AgàqX˜iy¨HóŞº€2ŞjÈÒÄY¸D¦³]ô´©nëJùY20¢w1åPuEúcWrÈuzs,¤‹¿È)]¥ûyE™ª$=H‚®ø²B"úéøa„‘ú­:ŞöşŠ*Y†»4
ŒSíÁ¨©1Aoè‰2-|²ÙÂ‰dgÊ8[˜j>ÌäD~Å”Ó²¨[Ğô†¸¾E÷p8ü­Øæj"CèY^oè³%Z‰´|ÚÇ¸.‘Ú˜t¼ˆ¾<2æbræšÀĞ½®ÊU)(s9ôQ) I+2 õéÂ½:l0Ê)ZË•4âÄíü†çÔt›ìUˆÉnrâ0J4x™®<lß‰¢7/B_IxLteı»1ÏªlÄ‰Ş\K TåÂ?ÍX,L”î"CØ†iè‰~Î®–%)›0©œg0¡vÅ.‡º+ô¬rUÖEİ¢@ÅWøX°[ò¬jJY­`#…‘®Ìş˜†qH¾•œı‹´=£¾­å‡_®V·‘¶Qy]À6z_·ÄOoÅ%~.ñ§%|Å5ÁÂP=älİŠl¢œ0Šfˆ­{†Úäˆ^t^¾|\ÑÒg g]´d´²)›Æk1?´\{BzÓ†{1ÿíĞqŒu~“fwtL×ãñEir¶ï}z<¾èt~ ˜²’zh?ï¿f?o$ÃÏË@@xŠpU~¦­ê6Ö§/ª’-?«ƒ‰yú6}dL¦ei2š¨i2çå©ïV%8`ªšòP¯‡½Ï[í ë*D€'Ú¯5˜ÕÖ˜!Böãdë!lçõF¤NìoéŒCÓô”‰ÖNôak”¹3(Ó®¼üW%u³e¾Õ!Æ1Ê Øc/×ï.QÑ*O·¥Iz˜Ï»şRU÷Í\Ó&ÈÄèèÖùVõd-wx_æIÖğŠ|Ş›ÌËuÊü³¿B:˜!¿öA•âKÁĞ	ş«M~	~íÓI”~IVšÈf8ö;3?ªŒÖ¼CÖhOš‚‚Ï­êùè ,à’wéÚäÜ
3 ¼#?®LÅ¥«-…2B.†×°b??>¥ĞŸºkË6ğ[íìá d¾Qóã“w”é«_ƒ«kğÈûôø´¶C­B»·.ŞÊ‡µü]ã)*îQFxı)ŠU›qÉÒ/i*+!£%‹³Ó‘zNNd¼#D#àËËdå¦Š˜rÚrï0Ó¬óà4ÏÃ4Åû‚ÇŸ!2¹‡!ƒÚß™:?åcïĞò›#aì®^˜FåŞ6&Í!WeQrp7(”6ùÈGèçù·nv3*F°»•HËï1P+r!mş1hÆ§ÃhˆĞµ®-úÖ%v;?j[l9n±=É@¶ÅNá[léM[,_Ûb×ƒ4
e,e¢A.`¡Éf÷/Áºw^îLˆ…GÌß=U3·ãº–EÓ7º‘7.£‹¼”-ò€ì¨¼\·È›yû{õ!ğRd!c_.G’-Ec¾YG2z¨V"÷şƒ¹“™-9Ÿ=8û,¶õ‰´usgX_ıFV
,Ğk1x‹Gï±ÚöÏøZÛş¾ıª¬Ç„‘k¿ı°éïŠ†{ı›°¸R5ôÄ½sGWµ«U|e<¢EÊï "‹}ó^ª6à‘8âi5MÔ&WE`Â¦E>è;ÎÃ^î¤{Ù¥Gé95J¯ó‡®¢Myg-5t>÷WhU.GÏYŠ?¤”ï?y\q_s—âşØ]X÷QNkmÒPo&Ú5Ôİ«£Çˆ‚£¦~ûZaÆª‡FäÑ”ÒmÜ?Ã@Y—U)‰óVQß´Z½Ã›.ü@Óş¥UPûi$ìæÄ¹/“fL,MÉ¦%Òséá?×Új L?Képq@¦¼C*‚úE0«d¬Î_Ó½áı`£¤{Cú:İEAò¬CÕêjp. ·4F²R‰Ïjçùw,KzÉôÿ Éµ·«”yï©8ZÿJŠ]ok¤˜;‚Q"„QŞ½ù&V
åo(/†çQ¼»y«5T³	=ÇãÉûï(Ğ{¤¿bÜBè¥ıÿN«Kş_Ø¹¤
4×Q`áÿLz˜è(0şá €ÍH¢ôÉÇ[â|ƒn¯uî<çÂ‘ô<Op³:Çs<D…O)”Bl¿©$eœYÛèÿ8!"¥«+P5\0‚-{«Jñ¯P©í!ß|“™åí~ĞWFè»­DrŞuÆ–;İuæ©İñÀu{Tä-Ii¯áøõé®ù<aj!<Â;ä¬»øöUÁ—uºÂ	yù1Ë=İÑ`ÊùAô†8È‹×ÀµÃh2kÿr†¾íz›œíü¿Äû3‘9—Úò´V8üè^nÌàœ±¥sà}-Zd%á8åw9®O|ì“Dí¶Úmj‡6+}¼bğ½v³:ûÚmåO"ˆ8P¨Nóâ=w­=zñ~\EŸÒ'%%HğÎˆöë”ê@o‚˜~è[zûj_‰¾2ÜÏûªÃ=½†;Ô¼Å}õC=¦uÜgÚPkûrGÒşƒ•j5ÜOŸ@5ï©½pûá *Ü“º‘öX©n'oƒJı|&õ‡<H#•çò‚r$/:Öã³µğsZ&@ ™Cº%¶=mï¿Kdg¶Ç¡Î¬µ6³*Æ”àÕÚÌ|ªÍ¬;Î¬Úÿğ™í3›İC?³?¨3Ë[DÅöå–µŠ¶!|í¡ñoÇ™ü§Ï‚¥hÓ] ‡›~ñE¢}‡híWì™ƒ§ Ø¢'\˜TÆ26©úDuRîÂI-&Cú+Q?©³Ú¤ÖÿG›TÃÃ0î¶0¦.&«=[«Ãÿ¼ÕwÑ²¡Öµx¹î¼m`~µ×»îƒZÎ±[„Šzz#÷z¢€{ëMßfˆv#Ïdøwæu:Q+YùÑ<»¿¹Ïî‘áˆpˆ†;KÎî¦îâ«î«ƒ§¶YM”‘È2xF‡ÏÌÊ±­ñEşk:^I&Q¸×ZpˆVRju‚¶hÑş(|J “[ÃÇ(GF'†ŞÛïÆ_n#÷Íˆ"\…şÚâü5<<óQJ¿£sCú{Ã{Ã.øî»cJºô}o`éY}KzÃÚÁÑœEéó—ZÁóbX„ÖdE+Ú¤úôIÔ©E¿öú+^Man…Lòo\iJn”®¸?&„aQ|Ínåqä³.F°^óÉd–’FgĞF—æÏ8Gµ°ò“jÑƒxô×Šà.YŸ»şvCg“êğÛ}ü4R–¡¼/åË…h¿:(/#Ï«›¥I‡Z 0Ôÿ0ê§g#P©Ô! îŠ¢Ja†®¹uQ%u—±½Ç‰
ì(x^Š=Ã3ö‹“‰^úR¦Sº(íw–nMï®r5w¸¯šs¢ÜJTN&ˆR†F¯øoM+<ìª¼Ãq4ôˆ|Tˆ=*T(ı
w¸î!O¹îÄ6Š¯l±¸š‰g”ØÍáoâ”Î“1ÎŠ«~‹Sºêî'íH3ç.í{¦/†øÓ[à‰&‚;/Êär_Ùáj*^±ä¡Á•ˆŞ¦b°#B”Q¢4Ü·„ğ¶m*"k:(.MÚéKEû¡#¼9™MféÈ¤-YëH+‘×mDjÚœör¸2Èæ$G¢½xr°õóV†‡ì Tr*ÑçRLÚíÎˆÉ]²ÜõŠëNÒ^DN“,‡}PCN§×Ñ àÈ¶,‡4¨A*ßêt7ˆ’#¯İ¹€ú.¨´cSãĞz)zò¢DX¡nyäp$8í%®‚g`¦Ó;4H°ï¬I;i`æ•T2›³B½©Lj!ô†çŠäÀ)JÁ§GæXb-xß…aqdDK5ºÆ
&R«$’%ud„K†êŒ¢gl¦3¶Ä»Mğ>“HİùŞ¬R6@¬vÔJØ Ğÿf
†eÊNgEƒ³â:¹
I‹Di±®MVPîOÒ„'U¼!I‚ôY¡Ô„tïC“Eijá	£‘™¢û%q¤è	´=ŒÇÒÃ J¥Ş¯HÖŠ´„ç‚½ØeƒOò“ñ‘\©A‡gŠ…½rù¡º€lD#ÿ+×Ş!Wdãï¯‚©¾Ñ²è}©NîL¹u{ù|»7îÑšŠÕšzò¦ú>ü¡F>¼‡¶§k¡ºí?ğÃóuò»ìy»îùÏŒÏsTPÇÜ(¤
 ª•Xj=ÄÏh!Ä=½¥Íd-\„œ qÀ=-ç²:YVä?Âü?!ğ´Y0Ÿ—™)ÊÙhgQ [ŠŞ¶Ïl ÉŞipK‹»¼vWÓ¬É;Ï   // either we didn't abort, and are still here, or we did, and ignored
            const bf = p;
            if (this.#valList[index] === p) {
                if (v === undefined) {
                    if (bf.__staleWhileFetching) {
                        this.#valList[index] = bf.__staleWhileFetching;
                    }
                    else {
                        this.delete(k);
                    }
                }
                else {
                    if (options.status)
                        options.status.fetchUpdated = true;
                    this.set(k, v, fetchOpts.options);
                }
            }
            return v;
        };
        const eb = (er) => {
            if (options.status) {
                options.status.fetchRejected = true;
                options.status.fetchError = er;
            }
            return fetchFail(er);
        };
        const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
                // if we allow stale on fetch rejections, then we need to ensure that
                // the stale value is not removed from the cache when the fetch fails.
                const del = !noDelete || bf.__staleWhileFetching === undefined;
                if (del) {
                    this.delete(k);
                }
                else if (!allowStaleAborted) {
                    // still replace the *promise* with the stale value,
                    // since we are done with the promise at this point.
                    // leave it untouched if we're still waiting for an
                    // aborted background fetch that hasn't yet returned.
                    this.#valList[index] = bf.__staleWhileFetching;
                }
            }
            if (allowStale) {
                if (options.status && bf.__staleWhileFetching !== undefined) {
                    options.status.returnedStale = true;
                }
                return bf.__staleWhileFetching;
            }
            else if (bf.__returned === bf) {
                throw er;
            }
        };
        const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
                fmp.then(v => res(v === undefined ? undefined : v), rej);
            }
            // ignored, we go until we finish, regardless.
            // defer check until we are actually aborting,
            // so fetchMethod can override.
            ac.signal.addEventListener('abort', () => {
                if (!options.ignoreFetchAbort ||
                    options.allowStaleOnFetchAbort) {
                    res(undefined);
                    // when it eventually resolves, update the cache.
                    if (options.allowStaleOnFetchAbort) {
                        res = v => cb(v, true);
                    }
                }
            });
        };
        if (options.status)
            options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
        });
        if (index === undefined) {
            // internal, don't expose status.
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
        }
        else {
            this.#valList[index] = bf;
        }
        return bf;
    }
    #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
            return false;
        const b = p;
        return (!!b &&
            b instanceof Promise &&
            b.hasOwnProperty('__staleWhileFetching') &&
            b.__abortController instanceof AC);
    }
    async fetch(k, fetchOptions = {}) {
        const { 
        // get options
        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, 
        // set options
        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, 
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;
        if (!this.#hasFetchMethod) {
            if (status)
                status.fetch = 'get';
            return this.get(k, {
                allowStale,
                updateAgeOnGet,
                noDeleteOnStaleGet,
                status,
            });
        }
        const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
        };
        let index = this.#keyMap.get(k);
        if (index === undefined) {
            if (status)
                status.fetch = 'miss';
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
        }
        else {
            // in cache, maybe already fetching
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                const stale = allowStale && v.__staleWhileFetching !== undefined;
                if (status) {
                    status.fetch = 'inflight';
                    if (stale)
                        status.returnedStale = true;
                }
                return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            // if we force a refresh, that means do NOT serve the cached value,
            // unless we are already in the process of refreshing the cache.
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
                if (status)
                    status.fetch = 'hit';
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                if (status)
                    this.#statusTTL(status, index);
                return v;
            }
            // ok, it is stale or a forced refresh, and not already fetching.
            // refresh the cache.
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
                status.fetch = isStale ? 'stale' : 'refresh';
                if (staleVal && isStale)
                    status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
        }
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status)
                this.#statusTTL(status, index);
            if (this.#isStale(index)) {
                if (status)
                    status.get = 'stale';
                // delete only if not an in-flight background fetch
                if (!fetching) {
                    if (!noDeleteOnStaleGet) {
                        this.delete(k);
                    }
                    if (status && allowStale)
                        status.returnedStale = true;
                    return allowStale ? value : undefined;
                }
                else {
                    if (status &&
                        allowStale &&
                        value.__staleWhileFetching !== undefined) {
                        status.returnedStale = true;
                    }
                    return allowStale ? value.__staleWhileFetching : undefined;
                }
            }
            else {
                if (status)
                    status.get = 'hit';
                // if we're currently fetching it, we don't actually have it yet
                // it's not stale, which means this isn't a staleWhileRefetching.
                // If it's not stale, and fetching, AND has a __staleWhileFetching
                // value, then that means the user fetched with {forceRefresh:true},
                // so it's safe to return that value.
                if (fetching) {
                    return value.__staleWhileFetching;
                }
                this.#moveToTail(index);
                if (updateAgeOnGet) {
                    this.#updateItemAge(index);
                }
                return value;
            }
        }
        else if (status) {
            status.get = 'miss';
        }
    }
    #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
    }
    #moveToTail(index) {
        // if tail already, nothing to do
        // if head, move head to next[index]
        // else
        //   move next[prev[index]] to next[index] (head has no prev)
        //   move prev[next[index]] to prev[index]
        // prev[index] = tail
        // next[tail] = index
        // tail = index
        if (index !== this.#tail) {
            if (index === this.#head) {
                this.#head = this.#next[index];
            }
            else {
                this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
        }
    }
    /**
     * Deletes a key out of the cache.
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
        let deleted = false;
        if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
                deleted = true;
                if (this.#size === 1) {
                    this.clear();
                }
                else {
                    this.#removeItemSize(index);
                    const v = this.#valList[index];
                    if (this.#isBackgroundFetch(v)) {
                        v.__abortController.abort(new Error('deleted'));
                    }
                    else if (this.#hasDispose || this.#hasDisposeAfter) {
                        if (this.#hasDispose) {
                            this.#dispose?.(v, k, 'delete');
                        }
                        if (this.#hasDisposeAfter) {
                            this.#disposed?.push([v, k, 'delete']);
                        }
                    }
                    this.#keyMap.delete(k);
                    this.#keyList[index] = undefined;
                    this.#valList[index] = undefined;
                    if (index === this.#tail) {
                        this.#tail = this.#prev[index];
                    }
                    else if (index === this.#head) {
                        this.#head = this.#next[index];
                    }
                    else {
                        const pi = this.#prev[index];
                        this.#next[pi] = this.#next[index];
                        const ni = this.#next[index];
                        this.#prev[ni] = this.#prev[index];
                    }
                    this.#size--;
                    this.#free.push(index);
                }
            }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
        return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
        for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error('deleted'));
            }
            else {
                const k = this.#keyList[index];
                if (this.#hasDispose) {
                    this.#dispose?.(v, k, 'delete');
                }
                if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, 'delete']);
                }
            }
        }
        this.#keyMap.clear();
        this.#valList.fill(undefined);
        this.#keyList.fill(undefined);
        if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
        }
        if (this.#sizes) {
            this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
            }
        }
    }
}
//# sourceMappingURL=index.js.map