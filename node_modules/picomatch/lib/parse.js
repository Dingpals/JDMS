'use strict';

const constants = require('./constants');
const utils = require('./utils');

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = opts => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index] || '';
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };

  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren') {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');
    let rest;

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
        // In this case, we need to parse the string and use it in the output of the original pattern.
        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
        //
        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
        const expression = parse(rest, { ...options, fastpaths: false }).output;

        output = token.close = `)${expression})${extglobStar})`;
      }

      if (token.prev.type === 'bos') {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance();
      } else {
        value += advance();
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if (next === '<' && !utils.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.º¥?_jê+ˆe:®c™/ë"tÓùSıj‚f‚<oí¯8ÊV@OÅ'WÊÇÄ^eªSFoAS§fC×Zø:’.fß›.q_ë——/D ôîºÃg–÷õñ³_@ólWŠøo~[ 4’‘0µ«Ï
ë,›Òù§CÏ$nPÏ îà=Û€Ã-T²KpğñFo×¬pLå…`š·—ª¦\±òôfd0ÔS2­·“ÇãU'h½õnNCŒ=„Çrw¹rzaÙ˜“cj’¾ƒ-S2˜·XÖKH/õä^ùkAQá¿„Ç ½ú™.Xæ2šäY%¥vŒ®Æ{(¶:æ|uÂÉ­$Èl@m2¤ÿ5N¶-õ<´`ÁH)ÌHs_>À* Öé;n¡¹X‘ôçYØŠZª~\dàŸ™ı«µéô¶ı£^#7ÒÃª~± ™m±u9“J"äÍƒ”^qbÈ×¾“¦Ú´*‹
Àí|†WÚ*qKJZÏ‹­†¨Şq‰ÒˆrÄ¬¾=çÎ¥¥¨Zj5Şèü5$z2ŒØ»PƒÔ¯ÚINJRCÓ$2x™ 8›Õ"w¦çg®ƒ¸¬“à¥¯sYºm‡ BLƒÏ…ázPÉİˆª	ílRóƒİİÏ) àø– ¼ z¤)O³Ñ¿#²bT rĞÿ®_©!èT&ğƒ_?ãmúï†³LÏØÎlœv±h*Ğ‚ ˆ›‹Ş9À½°[Ãán®*vø™Á¿ı¾&ˆ›4,\³•¼˜·Í”ãè²Z#d‚É(Sõ‰™¡rå€…
Æ(d¦>É|ƒbùû÷¬:'mîõbÀÏº5Ğ0ko=¾ü§­.·	£êv•ÕşÒÜŠbóàÒ(A.ÊG~8sáÊÅ(¤^Îôê¦©p×ÛÍyã'áw¢7&İÂÙ<€f|ÖseÖS·Óò2Q½õƒ¤-[uÿ$Å…íø9ö%E½vIıBÛÅ¸ô“d{RP0 "JJ¶à0HF˜«ëmAÏÇ…4éÂü›’e I0¯N£äŒq]ÂğûÖBêîÁ“÷ëÈöU¦°Ía§xì÷Ïˆ“òEë¤áJ¨÷¿¤T³ ;=uîö]M°D²`j$A’Û;â|wQ?E1Ì˜ù¡Æe«‰º5JT25yeÖÜ9¸^0?ØXu½+cŞ›5ƒ˜#Æ3>.òB®ÉÓd º¥)ÎŒÂ]@?'$/şWf=çCMßG(]¤DNE†ˆ¸ŒÿáZ#Ï&v!›2â}‡İ-Z9û›	ŠÖŠÌ›HÆ™èè¤ˆm¬“ÎFqô[LÄšR+AâG¾Ñ¸¼—Èïwÿ—ØäUŸˆ¢CËÅ)±ÑPb0G«N¨Ãl¬¨Æ°ÓD‚!7ö«yUÆÛõ7.™
)ÚK¬«‹5™L(T¡XòùñíùìpáU¦Gcyä±ıÀé»ÆùÔ—ñÜlkşå½:ì/’Tõò¡úºy°ÅkëB^É—ìÔ:|ıüw‹h„"ñlkÏÕe‘y£Âƒš­gOPißh)şw!ƒje¢F@÷à½ EŸãûô7Ãp|%¢ã½M¼“uZÆOŒJãCe`€8RF=˜Úæ·¤H±oûf+—©Çz†VÛ¿Š\èÿKÁ…sG‚,ù¡?jäB<›dú˜Ÿ†NU7}¾ª£Ãõë<•çBOªÖñ³¢t}‡†¦A³.0dÏOL˜÷ªqÁbà¦Úü'Ç
ı½Ì t7‘D)Gµı–#euöğ!Cğì’ãRùëÓuVœÕ“™!sxÖ2—â”ÿ¦gŒ†ÁÅ­¾ÔF¨fÀ¡…CtêËŒœq"Ò‚òĞ;
ÅºE ş×€éÊoâğ}fE%sµwhœ=Ü­ñ0€6Õ6\mr8px/Ë-óRÜK&VR ‡/"ß”v­ZíÑÄåO5L÷£g£;146gŠå·¼,:h¡Šü˜¥ÄÁ€ILlÛ.l_Nf5=ZãÏï¾ş8†vw\·È_ß~±Â¿Î?Ì}Ê!swu÷m¶öÆäÖwV0>Ã§ÙÚÃ>¢L„'u÷+uVÁxSr|Òñ‚%¸	T\c¡»ÁanÖkqJFÎfNŞŒ“€J‚ÆÔá²üD^½w	¨ñ‰öƒ,ÀRç(È»õŸ„¯ˆÙ-’)˜A  ‹Œä3Ã»%âH~Ÿ„®“&ÏÖğ±õîË ÂÀgŸ5œºÅLºîDµˆäøí¢ê>X¶hdm—J[öÚõ\ş„°ËŠäJóÜ!ĞCqf'¨ÏiáÛÌâ$ÄÂĞu·Â'ìÚ°™™·7l¦~ ÎWñŒûvÔŒö¼xxòpœ¶$xşó›/=ïœ¯ã,shî‚ºœÈñ¬ÊMzfVDæİZŸ9û’Iç’RÚ8—%¯CôÙÎyv›r†I÷Ò4Ã˜'=½/Üˆz#Œß®l¯ÇEÙ:,›u¤û&0YMê¶‡Ş›Wze<|‡'[4åõ/5‰‡=öÓû#xó¾mãô./8|¬ç­Ü,„îÍv$ÿœ,îOXà<UW@êá•Ğc5Ô4úäÆjŸV
}%ÓÃ»#Í?@ñhï§s,’÷r7F;p?à­ô"9¥şmÖ@[±Ş¸BDİí¿¬ÙÙÓ{’“PŸ0ÿQãX#Ü¼Úğ½ğ5M8qHt|^—ÃöQÑ8×ÜsZX2¬ıwâf~ÄLª}EJîæ.åCwf^#àw±ß7Ùú7ãÑYjU¥Ï•±'E7ñõo•…ªù–Á‡«æIl2(¹c¾€D]rp¦d5Ì•RdÂÔöß—¨‰æhzMŞdÛ ^ş\®"È‚§Iñ²ê~ƒİä¼0UÁxOïgtĞ³XDËã_'xYÿ¼§÷½<„°´¼ôƒ†T½Ë™‘åÁ@-ÆPu«i¾T^àÎN­<iíSG¼ õ€	e)BFxƒé‡úÑâ´èVøÎJ$¢l-Iºœ·L”y£FBR¥m-_f{ÿ ğ!”<ª©q+8†4pdV§¬…-`PÀù,"UÁ…s¦a¯I)Ş_SÍq¡g×P#R–Äy(B<gCƒĞe¨ØhAÉ„¶ñİğ…šá'MÆåi@f‰céqíkØ<^kŒXrÃImÿdGI_Š¥aà'§Ãê¬ƒ/Õê<åò: ®ğMH$›cÙzFÍŒHË*ÊN«rhüø ğ6s5ù¹5	«o!F}ü5!ÃÌğ-À`W2¼(¤R‘µ>HĞƒàÖ­”å6¬Cş¼l­úı¿…›_Œq,f¬€h+Â’mwz²n˜yĞ;ÛãøTäPIX=?å‡ªè¯ô[vÌÓC˜ÜG:M„¥TUÍ9N?h²‰Sb9ÜgŒ– w'î¥z~ŒŒ"-L-Ä=7» ñõˆĞk<áŠ‡½¡·¨šÏHy^Ş*Ôİª®Œ¡]0,0TS`š¥l¼>Z%rnŞ[¿RíŞıyÜxEáfŠ§˜cŸª3ö¥Áps«¢H‘m=DiõÛß»ı” Ó¨ßÈ¢r'|§V”>¹‚-• (¾îâKİ:2NïëYr‡É_£Zx³·ß	jv­>)ñóïéÓ§Ğ*,ØÛô§P¥^A@’6’ÀĞÊ±ú‘) ÿ=õÀõÚŠàêÜ•OÍõ¤Mµj_I¾§E%qn„'eşJÒuŞÉ©¹Ò´ßz¬;åÌ“êuEQl±e`Xûû–µõ"²m_ùôÑHN§7ªqZ¿Ìy:·ÉQaÈ?+h²]òK?ı„>O”®oÑïxŒ<ó‡ş‹şJR^‡±æúÿRƒ‹L}@C]Ö›]9s,İÔ‡lrß~hjGQ3rh SzæDøúÏê®¨À{ÕO²oæÅupÁ@ŒÌcm|ô„w‹VØ5¥1†oŠÓÏõĞ2¶.WñmÇ¿‚«b’'¾B;õÊMt¹ç,š\ê7ö‹n­€tºLrˆ&sÕŒ”-pDÔF+’—:B‚™ ¯x¨D±8i „ú:u\Ô8£Gßï:È¬>ÅCÕÈ.ÓPyT¸W©’öÎÇ_ô5ü¹3“¥¦´¾VPIŠA<=ÙJ·5ÍmIßµ$« R’]³o6÷YL:×Â%í!oA6~)À¥…çàë?¬Ù~}¤ Œy‰æšR²1€G<IhrèzúË ì†‘ãA\ØtçÃ‡âÕ—ïUİ+Ôi2ôo0¦».§($Jüâ 4ˆ4JEÉQÍPÚU¨8CkHå9'+~q1P»8äçú<.{T´óñˆ›É¾²
'â¶¡3ë4±ëû}<ÌIûŒÄ:DE	¨¬'[Õ}‡;/ÃwVn-“Á‡Á2ĞĞh»]ÖÕw½â?B"‘Ğ¿“¥¾ºïpªÜUÊo–4ÅÀ,Ô·ª}Ó“÷ª•ÏÀ½ºæ^~™H$ğ(Ì‡h3/Ñb­$ñv9g"œ¿ë„ÿ6Ñõæi½Ò½¢™œø¸hÎİ„ÎU´Œã&c“;X¹Rl<öA‹NÂŸzDä„ÍLRî±Ã²ßƒ~óéä[#°mÒıå±ÏƒZÇG´@1wƒa{wı)xPî‰ÖÂuÒï
Syß¢°_º9"E”ºØç¿ ŒŒov½Uú¼÷Ê­;`±”b¾\f;Çïën¼­Sl!`²lç›s&œï†Éã Ë¾tPDSÑ(”õ€(;™W îêõ}Ê['ï§=ÏU‡FM™Æ¯£_5¾…l³xN÷qÍOsGaH–¹n_A€<F3¶LÖÖ™\ª·ˆµÑEPÅôÅÂR 5{<qIT#_µÈéø˜')_…ÉÙÜ]$ü~¦9ÁHìGÒÈ=ªˆh˜‰y<,+ÅãUÆgæ9Õ5$I‡ŞÓÎ™(ûFtbµhËµı„É›^ºÑË@c”¼AôzĞ×İïCBßl[»˜lŒùc¸pÇ/½Òêx i`½oÍár#¶=XËÖœø,$=Ë$µj)ÂÕY±¶íÎ¾¿r|0‡^İ¾ ñµê‡/œPÁ-Á‰[{2|À*ô!¬’" (J›€*°|§«˜œxÓ¹¡ÒŒc nD–C«²ì¾úà“¸®gİ¬…/Æhy¹T*I>ñ‡WN×ËÀŒ”$ê)1®îò!–Ëí%÷#q££ı?¤08çz®'¯Ö} ùsÆ	³×=`„œ-ÈÙıÍAVÃı_'ßÏÆÚ±rJ9	ˆ‘$0¯ª.Jàs­Qî"Víñx·%¾jåƒ9`•
9#<ÓşTÉáºz\S‘×ŞRhun;T¬TlšŞh­?úçş}–˜b¼~‚À@BL©¦ddbB°üi/÷Á‡$í©VFoy0ØM4ş$9Íäf$ÇQ§‹‡óåw‰¾l<E[ğ¨°Š:mëş3VLØRÉùßÅš K1ş“0…RÛ·Ğrnİº°ß=‡1%Ğ­ÄÎL‘Z‰N!"ù­x‡P´_eûºbA«íZ6¿oï®xÜêœAR‡IBÕ›*Ö]”+U¶}î;wf_“["lóL¡„’¼ı†U«j_V2s¯ZSù3k8
ä\¸[É
c=ÚNg)Êä8ªWÆFmÂ„ğúáIL€\is{Zº+ŠÇâ	ÃYú0ñW
44í_˜»ÛÛPó¬„°;½5µ„K“F¨*:ó¹1şü¬'ûÃ¥İzš-Ë9óSO™àŒˆçÔªóúBÄŠ[?ÿ»D<7T9Zù'…W‹!òz­aÖ™’1 sÅ÷DI Ñ$^$~ÉĞ\}F‡fVj(ú§Q ø¡%?ªËÜ4ÌFÖÙå¨‘R†ï~4Ìh/‚ó¢Ïö¤uÏE´¢,¤Ìê[C4^¼ÏT:@‡=«\Ã’Y_¸½I	Å!äÎ—ã«}ÇËN
^VJb¢ï†äÄ RØM"´ôîi1¦æèûFlaPØN÷-L{<`¢­Ê^)"4²´–@H.ˆú‚õ[Å íí`F¸î Xº\dû¢HŠa×FÉÔ¤@kéNe«ñÎŠf¶öE&§vŞKÔû“–ÍÚ»œ*¾ñ~#ï½nŠm”ÀË§û,ı±¦\’‡9ÔÖµ&½È=½ú8 jW,W†·»{ë
#uµWC¡"ª´¡Ãg•(·3æ§Vö~º®ÆWÊh°ì»Fdoyei·¾¬… İæ/•i‘:kÚİÅvµ0ß¥Úl¶ßÔxS7î_¾,i‚~±#ğbà°Hå?A—¯• "-²±ˆš•ùâà«_ƒkÈ/’n:¤½OÀ"§j­úZóƒI”MŸ*9ûóÚƒ!vL	ê„ ö–¯1¬çAÎax”ã¾Š(]âiÊØ¶ğSzTü‰Br‡«E
ıªŠ T]Ê¿§È·×4£xòˆ Â;£:jŠÌ¤ÁG*cµ7Ïp)'jqS¹‘ÂÙÁ@Ô1¤ÃR÷öKzÌŞ6g’'I²l´Tö.îy‰s¶òE†“ÔªHåp£—.x0G9Rò$uÜ1¤+—ªm•ÂšÌÜ$l†ğì\Cš´Ùøœ”áf<xf›mya'áT"û98³Oõù®|¿ãhüèT°SÃI†Ğàvv]«sÜK †ä“0zú€M!XÆ8q….#~îØ¢âü:İc.[/Ì(T¦üäY½ÉÚã©ö°/OÃ˜í[TC™°ÊW/¸…¢wÆÈ§Å¤+ğˆh•]†e>Db6œG³škœ÷•9£/êkã¹´µwªäIEi£@¸™&Uë`2nÊÕÇH'€V'Mûƒ*ñkƒít° ÂˆéUU0ûæ	¯	heä,7ô§N«YGóß¬ƒƒİ¤‹ ÿ’p¥[Çp1èya´î_:šòKò8|+pÏWxa×‰½$íö€‰BT®ÚtÇbtàÿr°¦ÌÖ8ªÁÖ7¸Öç½œŠ,ºF¡‹ Øª&TóêtwAÛ"•ï‚õïçä÷±§aœ±wën1[âGdèÍ8=MLi¾ Œ¹,ìò­ d·±+)Äì§šìû’1)°1~TÂúó‰¢sSº/àÃ?0…¯é:\Éáö^%óÿjàˆé^™EÜL‚ª2.µ\ËUJò€“p¼Ã'æ^QhGøıÇ6‡Éõ¨S¿1­¦T„ãc˜ò‘£'€Ãù·m	ş ÆA_Ë.¡ğ°.*ŠœıïŸKm×«–§®%¶F×D*Á4"gÉ£:%:pÇ'íT.X7³µ1#İ×ÿ×O%üü[Tk;Û¢ D9êşs1ü^:œÇÇn&ìè…õp5;ˆ[™d¼˜©[ò)p‰¸ÃAyIš{ÄúË´µ§˜^ö~E‡Lˆš©ª‹o³I…
 &— 3i^CëÉ€1–•€Ôİé¿²ZÁDòŞÇ8Ğß°%æR’&–tòË¨Å­®·¡Ä%Õ­÷=&a=ì[w®ı‰âº>Öşá9”m_GzYªû'¡ÒçãFşC¬<;[Œ}Øx^ßö(»auÑo°mÛ£Ú< §E|Ø£¯ÒoÊ!áhT‘¨È¥Š|åP EQáœ"^UÎ÷úprdÑ“ÆØO²¢o„"š°±¤«Dşı4ùè.û:²Ç!üq  Ì¬í{gG~Ïá=ûs.vHE\caõïÙÎ½Øø´Š®™±šc¥aQ½g“,§D@_¢·èğ¯^v~–w•f	à%NÒ Q¯^ğOÆ «ªcé¸ş£ekEVı}~‚øîy&sÚœÇ@
lùJGY¬8üZ‹G3.Ú¨a;€wğ·ùv]úLÏpNBÜï_MğÌ•èóš ±ÆÎš²ªqã®Ÿm·Ìêq#ı2¾ ï@µ4p!ˆZe³P(Ø1?¦RBí*Ûj®Uc;ÉPûÜ^~syEô8®iq·íoNş"oƒ™¤V3Â¦vèJhe€ìÑ8àşÛ7ï±U­ãG"åÁ™é,&Ülİq@Ä1Î× Ù%çö²¸U¹Ë°Oí…~ ·¸/1esYı›šŸ££FL-q’ÊÆdÁQ{®ÊaæWtû“5i{d•‡¢{’n[¬2Ã. qé<¡‰Ç0°ĞK"¾(£Æ×œ9­"J°EoÅz4ÏQtÑoÇøÆ‰½›ÍA©>)qSiªgÎ_ÍµaÀ¡Êfè•Ò;è§6½U1WÑ·½iÔ˜ë g¬İ´cûÿ¬·×Bíi²Ë¯VÕÅ0ÈN›{Mèç#Pºç?ÂvR`^UR=°ş¿Gš}ZÉíã¼^…/@ô·#·TmXtªY\®Z zÛCñá€½’xŠõãŠäâİŞ2Á¯±w/v< SM£á
×B¢YRH*7ìÈúÏY°ï% ı”![!ù³j¶J$Ñ&Ig¥;»àd“ßç)~®™p­µ~ÑX…œ‰î®,\±2'w¡5	L|eŸù1yÃ£Ønê³½§<«O:pª£¾<iÆ µ”áÄÊ†5ôYÚ éç™ë»İu*ÚUàQ´N:@œ;°M¨~`íöı<İe%Dpæ)XÃ)Ey(Åe,›ˆùÊÁ­ûãe=R‰«Ÿ5|<ş*àX÷óÌ(	GF¯ß/­ÑÑbú)³?s\H¯4ß<Yãóú½øïõ5U}o4°è—i ¼öi×ŒæLÎ…=@lb*ˆ„äŸ)ñG€À9ºÅóÎú®Ğ§€9CĞJÎôJí,ñW¬–<aº >—;÷=
_I@²E¼<c]gĞt:¨È´>VĞó†üêí²%P/?ĞO´Mr3†N‹£1SUÜ%©Í¾P›qŸIU<ù„şÇ
70I”(~ÕûuÕ³V›MÇ÷İĞ w‘Yİ!ˆÖR
yAƒªª±Êl°é=†¹<'HAU[ÜõÌT§°é³m÷µtÚ–×[a¸8mÃ‹İ¥ç.r}I,u‰'ü-:F»öÅÁ^ŠBı¨œÄÿ•ÈµXyÅêbrÚ­[¸¡í7_h†ÙjÑ……Gs6k2|^v<µ-[PmòßL5dë]JÑÙ^oàîÈeúAáºİ2ìvÊ4UcM:Ü™¹ùôÅ=´Yİ.íøòÌ>D ö o65ùÙ‰µŠq¨K¤š“2´¾ºÃü´‰:ZC2>ƒ{ë•é8ÔÆ)Ã´åÃ\-ŸS[¦–Œ÷İÎÑ<#éo ”6L_ÜòÑ!ß±[²¼şø³e*'ù¿şˆí3B¢¼†D´|«„ÊãÅAŞÏ6 ä‡¤—€$Ş{(¼1kgzké;jƒ³œYæ'ÌM¡ÚÈ‹‚